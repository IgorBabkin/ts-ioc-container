---
import BaseLayout from "../layouts/BaseLayout.astro";
import CodeBlock from "../components/CodeBlock.astro";
import injectPropSpecCode from "../../../__tests__/readme/injectProp.spec.ts?raw";
import onConstructSpecCode from "../../../__tests__/hooks/OnConstruct.spec.ts?raw";
import onDisposeSpecCode from "../../../__tests__/hooks/OnDispose.spec.ts?raw";
import hookSpecCode from "../../../__tests__/hooks/hook.spec.ts?raw";
import customHooksSpecCode from "../../../__tests__/readme/customHooks.spec.ts?raw";
---

<BaseLayout
  title="Hooks"
  description="Hooks - Lifecycle hooks for instance initialization and cleanup (onConstruct, onDispose)"
>
  <article>
    <h1>Hooks</h1>

    <p>
      Hooks provide a way to execute code at specific lifecycle points of an instance. They enable
      initialization logic after construction, cleanup logic before disposal, property injection,
      and custom lifecycle management. The hook system is flexible and extensible, allowing you to
      create custom hooks for your specific needs.
    </p>

    <h2 id="what-are-hooks">What are Hooks?</h2>

    <p>
      Hooks are methods decorated with special decorators that execute at specific points in an
      instance's lifecycle. They can:
    </p>

    <ul>
      <li>Run initialization code after instance construction</li>
      <li>Execute cleanup logic before instance disposal</li>
      <li>Inject dependencies into properties</li>
      <li>Perform custom lifecycle operations</li>
    </ul>

    <p>
      The hook system uses <code>HooksRunner</code> to execute hooks, which can be synchronous or
      asynchronous. Hooks can resolve dependencies from the container, making them powerful tools
      for managing complex initialization scenarios.
    </p>

    <h2 id="onconstruct">OnConstruct Hooks</h2>

    <p>
      OnConstruct hooks execute after an instance is created. This is useful for initialization
      logic that needs access to the container or other dependencies that can't be injected via
      the constructor.
    </p>

    <h3>Basic Usage</h3>

    <p>
      Register an onConstruct hook on your container, then decorate methods with <code>@onConstruct</code>:
    </p>

    <CodeBlock
      code={onConstructSpecCode}
      lang="typescript"
      filename="__tests__/hooks/OnConstruct.spec.ts"
    />

    <h3>Use Cases</h3>
    <ul>
      <li>Post-construction initialization that requires container access</li>
      <li>Setting up properties that depend on other container services</li>
      <li>Validation or setup logic that needs to run after all dependencies are injected</li>
      <li>Initializing relationships or connections</li>
    </ul>

    <h2 id="ondispose">OnDispose Hooks</h2>

    <p>
      OnDispose hooks execute before an instance is disposed, allowing you to clean up resources,
      save state, or perform other cleanup operations.
    </p>

    <h3>Basic Usage</h3>

    <p>
      Register an onDispose hook on your container, then decorate methods with <code>@onDispose</code>:
    </p>

    <CodeBlock
      code={onDisposeSpecCode}
      lang="typescript"
      filename="__tests__/hooks/OnDispose.spec.ts"
    />

    <h3>Use Cases</h3>
    <ul>
      <li>Closing database connections or file handles</li>
      <li>Saving state or flushing buffers</li>
      <li>Unsubscribing from events or observers</li>
      <li>Releasing external resources</li>
      <li>Logging cleanup operations</li>
    </ul>

    <h2 id="property-injection">Property Injection</h2>

    <p>
      Property injection allows you to inject dependencies into properties using hooks. This is
      useful when constructor injection isn't possible or when you need to inject into base class
      properties.
    </p>

    <h3>Using injectProp with Hooks</h3>

    <p>
      The <code>injectProp</code> helper can be used with the <code>@hook</code> decorator to inject
      dependencies into properties:
    </p>

    <CodeBlock
      code={injectPropSpecCode}
      lang="typescript"
      filename="__tests__/readme/injectProp.spec.ts"
    />

    <h3>When to Use Property Injection</h3>
    <ul>
      <li>Injecting into base class properties</li>
      <li>Optional dependencies that might not always be available</li>
      <li>Circular dependency scenarios</li>
      <li>Framework integration where constructor injection is limited</li>
    </ul>

    <h2 id="custom-hooks">Custom Hooks</h2>

    <p>
      You can create custom hooks for any lifecycle event or application-specific scenario. Custom
      hooks use the same <code>HooksRunner</code> system but with your own hook names.
    </p>

    <h3>Creating Custom Hooks</h3>

    <p>
      Create a custom hook by instantiating a <code>HooksRunner</code> with a unique hook name:
    </p>

    <CodeBlock
      code={customHooksSpecCode}
      lang="typescript"
      filename="__tests__/readme/customHooks.spec.ts"
    />

    <h3>Synchronous vs Asynchronous Hooks</h3>

    <p>
      Hooks can be synchronous or asynchronous. Use the appropriate execution method:
    </p>

    <CodeBlock
      code={hookSpecCode}
      lang="typescript"
      filename="__tests__/hooks/hook.spec.ts"
    />

    <h3>Hook Execution Methods</h3>
    <ul>
      <li>
        <code>execute(instance, context)</code> - Execute synchronous hooks. Throws an error if
        any hook is asynchronous.
      </li>
      <li>
        <code>executeAsync(instance, context)</code> - Execute hooks asynchronously, supporting
        both sync and async hooks.
      </li>
    </ul>

    <h3>Hook Context</h3>

    <p>
      Hooks receive a <code>HookContext</code> that provides access to:
    </p>

    <ul>
      <li><code>instance</code> - The instance being hooked</li>
      <li><code>scope</code> - The container scope</li>
      <li><code>methodName</code> - The name of the method being executed</li>
      <li><code>resolveArgs()</code> - Resolve method arguments from the container</li>
      <li><code>invokeMethod(options)</code> - Invoke the hook method with arguments</li>
    </ul>

    <h2 id="best-practices">Best Practices</h2>

    <ul>
      <li>
        <strong>Use OnConstruct for initialization</strong> - Initialize dependencies, validate
        state, or set up connections after construction
      </li>
      <li>
        <strong>Use OnDispose for cleanup</strong> - Close resources, save state, or unsubscribe
        from events before disposal
      </li>
      <li>
        <strong>Keep hook logic simple</strong> - Hooks should perform focused operations, not
        complex business logic
      </li>
      <li>
        <strong>Resolve dependencies in hooks</strong> - Use <code>ctx.resolveArgs()</code> to
        inject dependencies that weren't available at construction time
      </li>
      <li>
        <strong>Handle async hooks properly</strong> - Use <code>executeAsync</code> when hooks
        may be asynchronous
      </li>
      <li>
        <strong>Register hooks once</strong> - Set up onConstruct and onDispose hooks when creating
        your root container
      </li>
      <li>
        <strong>Prefer constructor injection</strong> - Use property injection with hooks only when
        constructor injection isn't possible
      </li>
    </ul>
  </article>
</BaseLayout>

