---
layout: ../layouts/BaseLayout.astro
title: Container
description: Container - Core container functionality, scopes, and instance management
---

import CodeBlock from "../components/CodeBlock.astro";
import dependencyResolutionFlowDiagram from "@assets/diagrams/dependency-resolution-flow.mermaid?raw";
import scopeHierarchyDiagram from "@assets/diagrams/scope-hierarchy.mermaid?raw";
import createScopeFlowDiagram from "@assets/diagrams/create-scope-flow.mermaid?raw";
import crossScopeDependencyInjectionDiagram from "@assets/diagrams/cross-scope-dependency-injection.mermaid?raw";
import scopesSpecCode from "../../../__tests__/readme/scopes.spec.ts?raw";
import instancesSpecCode from "../../../__tests__/readme/instances.spec.ts?raw";
import filteringInstancesSpecCode from "../../../__tests__/readme/filteringInstances.spec.ts?raw";
import disposingSpecCode from "../../../__tests__/readme/disposing.spec.ts?raw";
import lazySpecCode from "../../../__tests__/readme/lazy.spec.ts?raw";
import containerModuleSpecCode from "../../../__tests__/readme/containerModule.spec.ts?raw";

# Container

**Goal:** Manage the lifecycle of dependencies, resolve them when requested, and maintain scoped instances.

The `Container` is the central component of the IoC system. Understanding containers is essential for effective dependency injection.

<h2 id="scopes" class="toc-link">Scopes</h2>

Scopes allow you to create isolated dependency contexts. In web applications, you typically have:

- **Application scope** - Singleton services like database pools, configuration
- **Request scope** - Per-request services like session, current user context
- **Transaction scope** - Database transaction boundaries

Each scope can have tags that control which providers are available, preventing accidental access to request-specific data from singletons.

### Request Scope Pattern (Express.js)

The most common pattern is creating a request-scoped container for each HTTP request:

<CodeBlock
  code={`// Middleware: Create request scope for each request
app.use((req, res, next) => {
  // Create isolated scope for this request
  req.container = appContainer.createScope({ tags: ['request'] });

  // Clean up when response finishes
  res.on('finish', () => req.container.dispose());
  next();
});

// SessionService is isolated per request - no data leaks between users
const session = req.container.resolve<SessionService>('ISessionService');
session.setCurrentUser(authenticatedUserId);`}
  lang="typescript"
  filename="Express.js middleware"
/>

### Tagged Scopes

Tags allow you to control which providers are available in which scopes. Services can be restricted to specific scope types for security and architectural clarity.

<CodeBlock
  code={scopesSpecCode}
  lang="typescript"
  filename="__tests__/readme/scopes.spec.ts"
/>

### Scope Hierarchy

Containers can create child scopes, forming a tree structure. Each scope maintains its own provider registry and instance cache, but can fall back to parent scopes for resolution.

<div class="diagram">
  <div class="mermaid" set:html={scopeHierarchyDiagram} />
</div>

### Creating a Scope

When you create a new scope using `createScope()`, the container follows a specific process to set up the child scope. The new scope maintains a reference to its parent, allowing it to access parent registrations while maintaining its own isolated instance cache.

<div class="diagram">
  <div class="mermaid" set:html={createScopeFlowDiagram} />
</div>

The scope creation process ensures that lifecycle hooks are properly inherited, all relevant registrations are available, and the new scope is properly registered in the parent's scope list for management and disposal.

### Scope Resolution Strategy

When resolving a dependency, the container follows this strategy:

1. Check if provider exists in current scope
2. Check if provider has access in current scope (scope access rule)
3. If not found, recursively check parent scopes
4. If found in parent, check access from current scope
5. Throw `DependencyNotFoundError` if not found anywhere

<h2 id="cross-scope-dependency-injection" class="toc-link">Cross-Scope Dependency Injection</h2>

### Scope System Rule (Similar to JavaScript Scoping)

The container scope system works like JavaScript's lexical scoping:

- **Inner scopes can access outer scopes**: Dependencies in child scopes can access dependencies from parent scopes ✅
- **Outer scopes cannot access inner scopes**: Dependencies in parent scopes cannot access dependencies from child scopes ❌

<CodeBlock
  code={`// JavaScript analogy
function parent() {
  const parentVar = 'accessible from child';

  function child() {
    const childVar = 'NOT accessible from parent';
    console.log(parentVar); // ✅ Works - child can access parent
  }

  console.log(childVar); // ❌ ReferenceError - parent cannot access child
}`}
  lang="typescript"
/>

**Important:** A service's resolution context is determined by **where it is registered**, not where it's requested from. This creates an important limitation when parent-scoped services try to inject child-scoped dependencies.

<div class="diagram">
  <div class="mermaid" set:html={crossScopeDependencyInjectionDiagram} />
</div>

### Resolution Context Principle

When a service is registered with `scope((c) => c.hasTag('parent'))`, it always resolves from the parent container—even if the service is requested through a child scope.

#### Parent → Child Dependency (❌ FAILS)

**Scenario:** Parent-scoped service A tries to inject child-scoped service B

<CodeBlock
  code={`// Service A - registered only for parent scope
@register(
  bindTo('ServiceA'),
  scope((c) => c.hasTag('parent'))
)
class ServiceA {
  constructor(@inject('ServiceB') serviceB: ServiceB) {
    // ❌ Throws DependencyNotFoundError
  }
}

// Service B - registered for child scope
@register(
  bindTo('ServiceB'),
  scope((c) => c.hasTag('child'))
)
class ServiceB { }`}
  lang="typescript"
/>

**Resolution flow:**

1. A is registered for parent scope only
2. A's resolution context = parent container
3. A looks for B in parent scope → parent's parent (EmptyContainer)
4. B only exists in child scope (invisible to parent)
5. **Result:** `DependencyNotFoundError` thrown

Even if A is requested from a child scope, A still resolves from the parent container internally.

#### Child → Parent Dependency (✅ WORKS)

**Scenario:** Child-scoped service B tries to inject parent-scoped service A

<CodeBlock
  code={`// Service A - registered for parent scope
@register(
  bindTo('ServiceA'),
  scope((c) => c.hasTag('parent'))
)
class ServiceA { }

// Service B - registered for child scope
@register(
  bindTo('ServiceB'),
  scope((c) => c.hasTag('child'))
)
class ServiceB {
  constructor(@inject('ServiceA') serviceA: ServiceA) {
    // ✅ Works - A is found via upward cascade
  }
}`}
  lang="typescript"
/>

**Resolution flow:**

1. B is registered for child scope
2. B's resolution context = child container
3. B looks for A: child scope → parent scope
4. A found in parent scope (accessible via cascade)
5. **Result:** Success

#### Summary

- **Upward resolution** (child → parent): ✅ Works via cascade
- **Downward resolution** (parent → child): ❌ Fails - parents can't see children

#### Workarounds

If you need a parent-scoped service to access child-scoped dependencies, consider these options:

<CodeBlock
  code={`// Option 1: Register for both scopes
@register(
  bindTo('ServiceA'),
  scope((c) => c.hasTag('parent') || c.hasTag('child'))
)
class ServiceA { }

// Option 2: Use scopeAccess for visibility control instead
@register(
  bindTo('ServiceA'),
  // Available in all scopes
  scopeAccess(({ invocationScope }) =>
    invocationScope.hasTag('parent') || invocationScope.hasTag('child')
  )
)
class ServiceA { }`}
  lang="typescript"
/>

<h2 id="dependency-resolution-flow" class="toc-link">Dependency Resolution Flow</h2>

The following sequence diagram illustrates how a dependency is resolved from the container:

<div class="diagram">
  <div class="mermaid" set:html={dependencyResolutionFlowDiagram} />
</div>

<h2 id="instance-management" class="toc-link">Instance Management</h2>

The container tracks all instances it creates, allowing you to query and manage them. This is particularly useful for cleanup operations, debugging, or implementing custom lifecycle management.

### Querying Instances

<CodeBlock
  code={instancesSpecCode}
  lang="typescript"
  filename="__tests__/readme/instances.spec.ts"
/>

### Filtering Instances

<CodeBlock
  code={filteringInstancesSpecCode}
  lang="typescript"
  filename="__tests__/readme/filteringInstances.spec.ts"
/>

<h2 id="disposal" class="toc-link">Disposal</h2>

Proper resource cleanup is essential for preventing memory leaks. The container provides a disposal mechanism that cleans up all resources and prevents further usage.

<CodeBlock
  code={disposingSpecCode}
  lang="typescript"
  filename="__tests__/readme/disposing.spec.ts"
/>

### Disposal Behavior

- Disposes the container only. Not children
- Unregisters all providers
- Clears all cached instances
- Throws `ContainerDisposedError` on any subsequent operations

<h2 id="lazy-loading" class="toc-link">Lazy Loading</h2>

Lazy loading defers the instantiation of dependencies until they're actually accessed. This can improve startup performance and enable circular dependency resolution.

<CodeBlock
  code={lazySpecCode}
  lang="typescript"
  filename="__tests__/readme/lazy.spec.ts"
/>

<h2 id="memory-management" class="toc-link">Memory Management</h2>

The container provides explicit disposal to prevent memory leaks:

- `dispose()` clears all providers and instances
- Child scopes are automatically disposed when parent is disposed
- Instance tracking allows manual cleanup if needed
- [Hooks](/ts-ioc-container/hooks#ondispose) can be used to release external resources during disposal

<h2 id="container-modules" class="toc-link">Container Modules</h2>

Container modules encapsulate registration logic, making it easy to organize and compose your dependency configuration. This is particularly useful for environment-specific setups or feature-based organization.

### Creating a Module

Modules implement the `IContainerModule` interface and use the `applyTo` method to register dependencies:

<CodeBlock
  code={containerModuleSpecCode}
  lang="typescript"
  filename="__tests__/readme/containerModule.spec.ts"
/>

### Use Cases

- **Environment configuration** - Different implementations for dev/staging/production
- **Feature organization** - Group related registrations together
- **Testing** - Easy to swap modules for test scenarios
- **Modular architecture** - Compose containers from smaller, reusable modules

<h2 id="key-design-decisions" class="toc-link">Key Design Decisions</h2>

### 1. Separation of Concerns

The architecture separates three distinct responsibilities:

- **Container**: Manages lifecycle and coordinates resolution
- **Provider**: Handles instance creation
- **Injector**: Handles dependency injection

This separation makes each component testable and replaceable independently.

### 2. Scope-Based Isolation

Scopes provide isolation while maintaining a parent-child relationship. This design enables:

- Request-level isolation in web applications
- Feature-level separation
- Hierarchical dependency resolution
- Per-scope singleton instances

### 3. Tag-Based Scoping

Tags provide a flexible way to control provider availability without hardcoding scope relationships. This:

- Enables environment-specific configurations
- Supports feature flags
- Allows dynamic scope matching
- Makes testing easier

### 4. Composite Pattern

The scope hierarchy uses the Composite pattern, where containers can contain other containers. This allows uniform treatment of individual containers and container hierarchies.

### 5. Null Object Pattern

The `EmptyContainer` class implements the Null Object pattern, providing a safe default parent for root containers. This eliminates null checks throughout the codebase.

<h2 id="best-practices" class="toc-link">Best Practices</h2>

- **Always dispose request scopes** - In Express.js, use `res.on('finish', () => req.container.dispose())` to clean up
- **Use tags for scope types** - Common tags: `application`, `request`, `transaction`, `admin`
- **Restrict sensitive services** - Use `scopeAccess()` to limit access to admin-only or application-only services
- **Keep singletons stateless** - Application-scoped singletons shouldn't hold request-specific state
- **Use lazy loading for expensive services** - Defer SMTP connections, external API clients until actually needed
- **Separate dev/prod with modules** - Use `IContainerModule` to swap implementations by environment

<h2 id="api-reference" class="toc-link">API Reference</h2>

### Container Methods

- `resolve<T>(key: DependencyKey | constructor<T>, options?: ResolveOptions): T` - Resolve a dependency
- `createScope(options?: ScopeOptions): IContainer` - Create a child scope
- `addRegistration(registration: IRegistration): IContainer` - Register a provider
- `dispose(): void` - Dispose the container and all resources
- `getInstances(): Iterable<Instance>` - Get all instances created by this container
- `hasTag(tag: Tag): boolean` - Check if container has a specific tag