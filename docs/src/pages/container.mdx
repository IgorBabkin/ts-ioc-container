---
layout: ../layouts/BaseLayout.astro
title: Container
description: Container - Core container functionality, scopes, and instance management
---

import CodeBlock from "../components/CodeBlock.astro";
import dependencyResolutionFlowDiagram from "@assets/diagrams/dependency-resolution-flow.mermaid?raw";
import scopeHierarchyDiagram from "@assets/diagrams/scope-hierarchy.mermaid?raw";
import createScopeFlowDiagram from "@assets/diagrams/create-scope-flow.mermaid?raw";
import scopesSpecCode from "../../../__tests__/readme/scopes.spec.ts?raw";
import instancesSpecCode from "../../../__tests__/readme/instances.spec.ts?raw";
import filteringInstancesSpecCode from "../../../__tests__/readme/filteringInstances.spec.ts?raw";
import disposingSpecCode from "../../../__tests__/readme/disposing.spec.ts?raw";
import lazySpecCode from "../../../__tests__/readme/lazy.spec.ts?raw";
import containerModuleSpecCode from "../../../__tests__/readme/containerModule.spec.ts?raw";

# Container

The `Container` is the central component of the IoC system. It manages the lifecycle of dependencies, resolves them when requested, and maintains scoped instances. Understanding containers is essential for effective dependency injection.

<h2 id="scopes" class="toc-link">Scopes</h2>

Scopes allow you to create isolated dependency contexts. In web applications, you typically have:

- **Application scope** - Singleton services like database pools, configuration
- **Request scope** - Per-request services like session, current user context
- **Transaction scope** - Database transaction boundaries

Each scope can have tags that control which providers are available, preventing accidental access to request-specific data from singletons.

### Request Scope Pattern (Express.js)

The most common pattern is creating a request-scoped container for each HTTP request:

<CodeBlock
  code={`// Middleware: Create request scope for each request
app.use((req, res, next) => {
  // Create isolated scope for this request
  req.container = appContainer.createScope({ tags: ['request'] });

  // Clean up when response finishes
  res.on('finish', () => req.container.dispose());
  next();
});

// SessionService is isolated per request - no data leaks between users
const session = req.container.resolve<SessionService>('ISessionService');
session.setCurrentUser(authenticatedUserId);`}
  lang="typescript"
  filename="Express.js middleware"
/>

### Tagged Scopes

Tags allow you to control which providers are available in which scopes. Services can be restricted to specific scope types for security and architectural clarity.

<CodeBlock
  code={scopesSpecCode}
  lang="typescript"
  filename="__tests__/readme/scopes.spec.ts"
/>

### Scope Hierarchy

Containers can create child scopes, forming a tree structure. Each scope maintains its own provider registry and instance cache, but can fall back to parent scopes for resolution.

<div class="diagram">
  <div class="mermaid" set:html={scopeHierarchyDiagram} />
</div>

### Creating a Scope

When you create a new scope using `createScope()`, the container follows a specific process to set up the child scope. The new scope maintains a reference to its parent, allowing it to access parent registrations while maintaining its own isolated instance cache.

<div class="diagram">
  <div class="mermaid" set:html={createScopeFlowDiagram} />
</div>

The scope creation process ensures that lifecycle hooks are properly inherited, all relevant registrations are available, and the new scope is properly registered in the parent's scope list for management and disposal.

### Scope Resolution Strategy

When resolving a dependency, the container follows this strategy:

1. Check if provider exists in current scope
2. Check if provider has access in current scope (scope access rule)
3. If not found, recursively check parent scopes
4. If found in parent, check access from current scope
5. Throw `DependencyNotFoundError` if not found anywhere

<h2 id="dependency-resolution-flow">Dependency Resolution Flow</h2>

The following sequence diagram illustrates how a dependency is resolved from the container:

<div class="diagram">
  <div class="mermaid" set:html={dependencyResolutionFlowDiagram} />
</div>

<h2 id="instance-management" class="toc-link">Instance Management</h2>

The container tracks all instances it creates, allowing you to query and manage them. This is particularly useful for cleanup operations, debugging, or implementing custom lifecycle management.

### Querying Instances

<CodeBlock
  code={instancesSpecCode}
  lang="typescript"
  filename="__tests__/readme/instances.spec.ts"
/>

### Filtering Instances

<CodeBlock
  code={filteringInstancesSpecCode}
  lang="typescript"
  filename="__tests__/readme/filteringInstances.spec.ts"
/>

<h2 id="disposal">Disposal</h2>

Proper resource cleanup is essential for preventing memory leaks. The container provides a disposal mechanism that cleans up all resources and prevents further usage.

<CodeBlock
  code={disposingSpecCode}
  lang="typescript"
  filename="__tests__/readme/disposing.spec.ts"
/>

### Disposal Behavior

- Disposes the container only. Not children
- Unregisters all providers
- Clears all cached instances
- Throws `ContainerDisposedError` on any subsequent operations

<h2 id="lazy-loading">Lazy Loading</h2>

Lazy loading defers the instantiation of dependencies until they're actually accessed. This can improve startup performance and enable circular dependency resolution.

<CodeBlock
  code={lazySpecCode}
  lang="typescript"
  filename="__tests__/readme/lazy.spec.ts"
/>

<h2 id="memory-management">Memory Management</h2>

The container provides explicit disposal to prevent memory leaks:

- `dispose()` clears all providers and instances
- Child scopes are automatically disposed when parent is disposed
- Instance tracking allows manual cleanup if needed
- [Hooks](/ts-ioc-container/hooks#ondispose) can be used to release external resources during disposal

<h2 id="container-modules">Container Modules</h2>

Container modules encapsulate registration logic, making it easy to organize and compose your dependency configuration. This is particularly useful for environment-specific setups or feature-based organization.

### Creating a Module

Modules implement the `IContainerModule` interface and use the `applyTo` method to register dependencies:

<CodeBlock
  code={containerModuleSpecCode}
  lang="typescript"
  filename="__tests__/readme/containerModule.spec.ts"
/>

### Use Cases

- **Environment configuration** - Different implementations for dev/staging/production
- **Feature organization** - Group related registrations together
- **Testing** - Easy to swap modules for test scenarios
- **Modular architecture** - Compose containers from smaller, reusable modules

<h2 id="key-design-decisions">Key Design Decisions</h2>

### 1. Separation of Concerns

The architecture separates three distinct responsibilities:

- **Container**: Manages lifecycle and coordinates resolution
- **Provider**: Handles instance creation
- **Injector**: Handles dependency injection

This separation makes each component testable and replaceable independently.

### 2. Scope-Based Isolation

Scopes provide isolation while maintaining a parent-child relationship. This design enables:

- Request-level isolation in web applications
- Feature-level separation
- Hierarchical dependency resolution
- Per-scope singleton instances

### 3. Tag-Based Scoping

Tags provide a flexible way to control provider availability without hardcoding scope relationships. This:

- Enables environment-specific configurations
- Supports feature flags
- Allows dynamic scope matching
- Makes testing easier

### 4. Composite Pattern

The scope hierarchy uses the Composite pattern, where containers can contain other containers. This allows uniform treatment of individual containers and container hierarchies.

### 5. Null Object Pattern

The `EmptyContainer` class implements the Null Object pattern, providing a safe default parent for root containers. This eliminates null checks throughout the codebase.

<h2 id="best-practices">Best Practices</h2>

- **Always dispose request scopes** - In Express.js, use `res.on('finish', () => req.container.dispose())` to clean up
- **Use tags for scope types** - Common tags: `application`, `request`, `transaction`, `admin`
- **Restrict sensitive services** - Use `scopeAccess()` to limit access to admin-only or application-only services
- **Keep singletons stateless** - Application-scoped singletons shouldn't hold request-specific state
- **Use lazy loading for expensive services** - Defer SMTP connections, external API clients until actually needed
- **Separate dev/prod with modules** - Use `IContainerModule` to swap implementations by environment

<h2 id="api-reference">API Reference</h2>

### Container Methods

- `resolve<T>(key: DependencyKey | constructor<T>, options?: ResolveOptions): T` - Resolve a dependency
- `createScope(options?: ScopeOptions): IContainer` - Create a child scope
- `addRegistration(registration: IRegistration): IContainer` - Register a provider
- `dispose(): void` - Dispose the container and all resources
- `getInstances(): Iterable<Instance>` - Get all instances created by this container
- `hasTag(tag: Tag): boolean` - Check if container has a specific tag