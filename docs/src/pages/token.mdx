---
layout: ../layouts/BaseLayout.astro
title: Token
description: Token - Token types for dependency keys (InjectionToken, SingleToken, GroupAliasToken, etc.)
---

import CodeBlock from "../components/CodeBlock.astro";
import tokenHierarchyDiagram from "@assets/diagrams/token-hierarchy.mermaid?raw";
import tokenSpecCode from "../../../__tests__/readme/token.spec.ts?raw";
import tokenGroupAliasSpecCode from "../../../__tests__/readme/tokenGroupAlias.spec.ts?raw";
import tokenSingleAliasSpecCode from "../../../__tests__/readme/tokenSingleAlias.spec.ts?raw";
import tokenArgsSpecCode from "../../../__tests__/readme/tokenArgs.spec.ts?raw";
import tokenLazySpecCode from "../../../__tests__/readme/tokenLazy.spec.ts?raw";
import tokenArgsFnSpecCode from "../../../__tests__/readme/tokenArgsFn.spec.ts?raw";

# Token

Tokens are used to identify and resolve dependencies in the container. The library provides several token types for different use cases, each offering different levels of type safety and flexibility.

<h2 id="why-tokens">Why Tokens?</h2>

While you can use plain strings or symbols as dependency keys, tokens provide additional benefits:

- **Type Safety**: Tokens carry type information, improving IntelliSense and compile-time checks
- **Uniqueness**: Tokens ensure unique identification, preventing accidental key collisions
- **Features**: Some tokens support additional features like argument binding and lazy loading
- **Refactoring**: Tokens make refactoring safer by providing a single source of truth

<h2 id="token-hierarchy">Token Hierarchy</h2>

All tokens in the library extend the abstract `InjectionToken` base class, which defines the common interface for dependency resolution. The following diagram shows the inheritance hierarchy and relationships between different token types:

<div class="diagram">
  <div class="mermaid" set:html={tokenHierarchyDiagram}></div>
</div>

**Key Points:**

- `InjectionToken` is the abstract base class that all tokens extend
- `SingleToken` is a concrete implementation for simple dependency keys
- `GroupAliasToken` extends `InjectionToken` for grouping multiple implementations (resolves to array)
- `SingleAliasToken` extends `InjectionToken` for grouping implementations (resolves to single instance)

<h2 id="select-utility">The `select` Utility</h2>

The `select` utility is a convenient helper for creating tokens and accessing container features in a type-safe way. It provides shortcuts for common token operations and is the recommended way to work with tokens in your application.

### select.token()

Creates a `SingleToken` for resolving dependencies by key. Use it with the `@inject` decorator:

- `@inject(s.token('ILogger'))` - Basic usage
- `@inject(s.token('ILogger').args(...))` - With arguments
- `@inject(s.token('Service').lazy())` - With lazy loading

### select.alias()

Creates a `GroupAliasToken` for resolving multiple implementations. Useful for plugin systems and middleware:

- `const token = s.alias('IMiddleware')`
- `@inject(token) middleware: IMiddleware[]` - Injects array of all implementations

### select.instances()

Creates a `GroupInstanceToken` to filter container instances by predicate:

- `@inject(s.instances(predicate))` - Filter by predicate function
- `@inject(s.instances())` - Get all instances

### select.scope.current

Injects the current container scope. Use this to access the container within your classes:

- `@inject(s.scope.current) scope: IContainer`

### select.scope.create()

Creates a new child scope on resolution. The new scope is created each time the dependency is resolved:

- `@inject(s.scope.create({ tags: ['request'] })) requestScope: IContainer`

<h2 id="single-token">SingleToken</h2>

`SingleToken` is a simple token that wraps a string or symbol key. It provides type safety while maintaining simplicity.

<CodeBlock code={tokenSpecCode} lang="typescript" filename="__tests__/readme/token.spec.ts" />

<h2 id="group-alias-token">GroupAliasToken</h2>

`GroupAliasToken` is used to group multiple registrations under a common alias. This is perfect for plugin systems or middleware. It resolves to an array of all implementations bound to the alias.

<CodeBlock code={tokenGroupAliasSpecCode} lang="typescript" filename="__tests__/readme/tokenGroupAlias.spec.ts" />

<h2 id="single-alias-token">SingleAliasToken</h2>

`SingleAliasToken` is similar to `GroupAliasToken`, but resolves to a single instance instead of an array. This is useful when you want to use multiple interfaces for the same implementation.

<CodeBlock code={tokenSingleAliasSpecCode} lang="typescript" filename="__tests__/readme/tokenSingleAlias.spec.ts" />

<h2 id="argument-binding">Argument Binding</h2>

Tokens support argument binding, allowing you to pass arguments when resolving:

<CodeBlock code={tokenArgsSpecCode} lang="typescript" filename="__tests__/readme/tokenArgs.spec.ts" />

<h2 id="lazy-loading">Lazy Loading</h2>

Tokens support lazy loading, deferring instantiation until access:

<CodeBlock code={tokenLazySpecCode} lang="typescript" filename="__tests__/readme/tokenLazy.spec.ts" />

<h2 id="dynamic-arguments">Dynamic Arguments</h2>

Tokens support dynamic argument resolution using functions:

<CodeBlock code={tokenArgsFnSpecCode} lang="typescript" filename="__tests__/readme/tokenArgsFn.spec.ts" />

<h2 id="additional-token-types">Additional Token Types</h2>

The library provides several specialized token types for advanced use cases. These tokens are typically used internally by the framework but can also be used directly when needed.

### ClassToken

`ClassToken` wraps a class constructor and supports argument binding, lazy loading, and custom argument functions. It's primarily used internally when resolving classes directly.

**Usage:** `new ClassToken(MyService)`
Supports: `args()`, `argsFn()`, `lazy()`

### FunctionToken

`FunctionToken` wraps a custom resolution function. This is used by `select.scope.current` and `select.scope.create()` to inject container scopes. The function receives the container and returns the resolved value.

**Note:** Does not support `args()`, `argsFn()`, or `lazy()` methods (throws `MethodNotImplementedError`).

### ConstantToken

`ConstantToken` always returns a constant value. It's used internally by the `@inject` decorator to pass literal values. The token ignores the container and always returns the same value.

**Note:** Does not support `args()`, `argsFn()`, or `lazy()` methods.

### GroupInstanceToken

`GroupInstanceToken` filters container instances by a predicate function. This is used by `select.instances()` to query instances. It supports cascade control to include or exclude parent scope instances.

**Usage:**
- `new GroupInstanceToken(predicate)` - Filter instances
- `token.cascade(false)` - Current scope only

**Note:** Does not support `args()`, `argsFn()`, or `lazy()` methods.