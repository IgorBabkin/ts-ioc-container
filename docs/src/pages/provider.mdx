---
layout: ../layouts/BaseLayout.astro
title: Provider
description: Provider - Dependency factories with singleton, args, visibility, alias, and decorator features
---

import CodeBlock from "../components/CodeBlock.astro";
import providerPipelineDiagram from "../diagrams/provider-pipeline.mermaid?raw";
import providerSpecCode from "../../../__tests__/readme/Singleton.spec.ts?raw";
import aliasSpecCode from "../../../__tests__/readme/alias.spec.ts?raw";
import decorateSpecCode from "../../../__tests__/readme/decorate.spec.ts?raw";
import visibilitySpecCode from "../../../__tests__/readme/visibility.spec.ts?raw";

# Provider

Providers are factories that create dependency instances. They can be configured with various features like singletons, argument binding, visibility control, aliases, and decorators. Understanding providers is key to mastering the IoC container.

<h2 id="factory-pattern">Factory Pattern</h2>

Providers implement the Factory pattern, encapsulating the creation logic of dependencies. This allows for complex instantiation logic while keeping the container simple.

<h2 id="provider-types">Provider Types</h2>

There are three main ways to create providers:

- **Class Provider**: `Provider.fromClass(Logger)` - Creates instances from a class
- **Value Provider**: `Provider.fromValue(value)` - Returns a constant value
- **Factory Provider**: `new Provider((container, ...args) => ...)` - Custom factory function

<h2 id="singleton">Singleton</h2>

Singleton providers ensure only one instance is created per scope. This is perfect for services like loggers, database connections, or configuration managers.

<CodeBlock
  code={providerSpecCode}
  lang="typescript"
  filename="__tests__/readme/provider.spec.ts"
/>

### Per-Scope Singletons

Each scope maintains its own singleton instance. This means different scopes will have different instances:

<CodeBlock
  code={`const container = new Container()
  .addRegistration(R.fromClass(Logger));
const child = container.createScope();

// Different instances in different scopes
expect(container.resolve('logger')).not.toBe(child.resolve('logger'));

// Same instance within the same scope
expect(child.resolve('logger')).toBe(child.resolve('logger'));`}
  lang="typescript"
/>

### Use Cases

- Shared state within a scope
- Expensive object creation (database connections, HTTP clients)
- Configuration objects
- Service locators

<h2 id="arguments">Arguments</h2>

Argument providers allow you to bind constructor arguments at registration time. This is useful for configuration values, dependencies that should be resolved at provider creation, or default values.

<CodeBlock
  code={providerSpecCode}
  lang="typescript"
  filename="__tests__/readme/provider.spec.ts"
/>

### Argument Priority

Provider arguments take precedence over arguments passed to `resolve()`:

<CodeBlock
  code={`const container = new Container()
  .addRegistration(R.fromClass(Logger).pipe(args('name')));

// Provider argument 'name' takes priority
const logger = container.resolve<Logger>('logger', { args: ['file'] });
expect(logger.name).toBe('name');
expect(logger.type).toBe('file'); // Second argument still passed`}
  lang="typescript"
/>

<h2 id="visibility">Visibility</h2>

Visibility control allows you to restrict which scopes can access certain dependencies using `ScopeAccessRule`. This is useful for implementing access control, feature flags, or environment-specific services.

<CodeBlock
  code={visibilitySpecCode}
  lang="typescript"
  filename="__tests__/readme/visibility.spec.ts"
/>

### Use Cases

- Admin-only services
- Environment-specific dependencies (dev/staging/prod)
- Feature flags
- Security boundaries

<h2 id="alias">Alias</h2>

Aliases allow you to group multiple registrations under a common identifier. This is perfect for plugin systems, middleware, or any scenario where you need to resolve multiple implementations of the same interface.

<CodeBlock
  code={aliasSpecCode}
  lang="typescript"
  filename="__tests__/readme/alias.spec.ts"
/>

### Use Cases

- Middleware registration
- Plugin systems
- Multiple implementations of an interface
- Event handlers or observers

<h2 id="decorator">Decorator</h2>

The decorator pattern allows you to wrap instances with additional functionality without modifying the original class. This is useful for cross-cutting concerns like logging, caching, or transaction management.

<CodeBlock
  code={decorateSpecCode}
  lang="typescript"
  filename="__tests__/readme/decorate.spec.ts"
/>

### Use Cases

- Cross-cutting concerns (logging, caching, transactions)
- AOP (Aspect-Oriented Programming)
- Wrapping services with additional behavior
- Proxy patterns

<h2 id="lazy-loading">Lazy Loading</h2>

Lazy providers defer instantiation until the dependency is actually accessed. This can improve startup performance and enable circular dependency resolution.

<CodeBlock
  code={providerSpecCode}
  lang="typescript"
  filename="__tests__/readme/provider.spec.ts"
/>

<h2 id="provider-pipeline">Provider Pipeline</h2>

Providers can be composed using the pipeline pattern. Each transformation wraps the provider with additional functionality:

<div class="diagram">
  <div class="mermaid" set:html={providerPipelineDiagram} />
</div>

### Provider Composition Example

<CodeBlock
  code={`const provider = Provider.fromClass(Logger)
  .pipe(args('/config.json'))       // 1. Bind arguments
  .pipe(singleton())                // 2. Cache instances
  .pipe(scopeAccess(rule))          // 3. Control visibility
  .pipe(lazy());                    // 4. Defer creation

// Each pipe wraps the previous provider
// Final provider: Lazy(Visibility(Singleton(Args(Base))))
`}
  lang="typescript"
/>

### Decorator Pattern

The provider pipeline uses the Decorator pattern, allowing features to be added incrementally without modifying the base provider. Each pipe operation wraps the provider with additional functionality.

### Composable Providers

The pipeline pattern allows providers to be composed from smaller pieces. This design:

- Keeps the base provider simple
- Allows features to be added incrementally
- Makes the system extensible
- Follows the Open/Closed Principle

You can also use the `pipe` method in registrations:

<CodeBlock
  code={`const container = new Container()
  .addRegistration(
    R.fromClass(ConfigService)
      .pipe(args('/default/config.json'))
      .pipe(singleton())
      .pipe(scopeAccess(({ invocationScope }) => invocationScope.hasTag('admin')))
  );`}
  lang="typescript"
/>

<h2 id="performance-considerations">Performance Considerations</h2>

### Singleton Caching

Singleton providers cache instances per scope, avoiding unnecessary object creation. The cache is implemented using a `Map` for O(1) lookup performance.

### Lazy Loading

Lazy providers use JavaScript proxies to defer instantiation until access. This improves startup time by avoiding eager initialization of unused dependencies.

### Provider Lookup

Providers are stored in a `Map` keyed by `DependencyKey`, providing O(1) lookup performance. Alias resolution uses a separate `AliasMap` for efficient multi-key lookups.

<h2 id="custom-providers">Custom Providers</h2>

Implement `IProvider` or extend `ProviderDecorator` to create custom providers:
<CodeBlock
  code={`class CustomProvider extends ProviderDecorator {
  resolve(container: IContainer, options: ProviderOptions): T {
    // Your custom resolution logic
  }
}`}
  lang="typescript"
/>

<h2 id="best-practices">Best Practices</h2>

- **Use singletons for expensive resources** - Database connections, HTTP clients, configuration objects
- **Prefer argsFn for dynamic values** - When arguments depend on other container values
- **Use visibility for security** - Restrict access to sensitive services
- **Aliases for collections** - Group related services together
- **Decorators for cross-cutting concerns** - Keep your core classes clean
- **Lazy loading for performance** - Defer expensive object creation