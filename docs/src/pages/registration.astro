---
import BaseLayout from "../layouts/BaseLayout.astro";
import CodeBlock from "../components/CodeBlock.astro";
import registrationFlowDiagram from "../diagrams/registration-flow.mermaid?raw";
---

<BaseLayout
  title="Registration"
  description="Registration - Registering providers with keys and scopes"
>
  <article>
    <h1>Registration</h1>

    <p>
      Registrations connect providers to the container with keys and
      configuration. They can be created using decorators or the fluent API,
      providing flexibility in how you organize your dependency configuration.
    </p>

    <h2>Registration Flow</h2>

    <p>
      The following diagram shows how registrations are processed and applied to
      containers:
    </p>

    <div class="diagram">
      <div class="mermaid" set:html={registrationFlowDiagram} />
    </div>

    <h2>Registration Methods</h2>

    <p>There are several ways to create and apply registrations:</p>

    <ul>
      <li>
        <strong>Decorator-based</strong>: Using <code>@register</code> decorator
      </li>
      <li>
        <strong>Fluent API</strong>: Using <code>Registration</code> class methods
      </li>
      <li>
        <strong>Direct registration</strong>: Using <code
          >container.register()</code>
      </li>
    </ul>

    <h2>Decorator-Based Registration</h2>

    <p>
      The <code>@register</code> decorator provides a declarative way to register
      classes. This is the most convenient approach for most use cases.
    </p>

    <h3>Basic Registration</h3>

    <CodeBlock code={`import { bindTo, Container, register, Registration as R } from 'ts-ioc-container';

@register(bindTo('ILogger'))
class Logger {
  log(message: string) {
    console.log(message);
  }
}

const container = new Container()
  .addRegistration(R.fromClass(Logger));

const logger = container.resolve('ILogger');
expect(logger).toBeInstanceOf(Logger);`} lang="typescript" />

    <h3>With Multiple Features</h3>

    <CodeBlock code={`import {
  bindTo,
  Container,
  register,
  Registration as R,
  scope,
  singleton,
} from 'ts-ioc-container';

@register(
  bindTo('ILogger'),
  scope((s) => s.hasTag('root')),
  singleton()
)
class Logger {
  log(message: string) {
    console.log(message);
  }
}

const root = new Container({ tags: ['root'] })
  .addRegistration(R.fromClass(Logger));

const logger1 = root.resolve('ILogger');
const logger2 = root.resolve('ILogger');

// Same instance (singleton)
expect(logger1).toBe(logger2);`} lang="typescript" />

    <h2>Fluent API Registration</h2>

    <p>
      The fluent API provides more control and is useful when you need dynamic
      registration or want to avoid decorators.
    </p>

    <h3>Class Registration</h3>

    <CodeBlock code={`import { Container, Registration as R } from 'ts-ioc-container';

class Logger {
  log(message: string) {
    console.log(message);
  }
}

const container = new Container()
  .addRegistration(R.fromClass(Logger).bindToKey('ILogger'));

const logger = container.resolve('ILogger');
expect(logger).toBeInstanceOf(Logger);`} lang="typescript" />

    <h3>Value Registration</h3>

    <CodeBlock code={`const container = new Container()
  .addRegistration(R.fromValue('Hello World').bindToKey('greeting'));

const greeting = container.resolve('greeting');
expect(greeting).toBe('Hello World');`} lang="typescript" />

    <h3>Factory Registration</h3>

    <CodeBlock code={`const container = new Container()
  .addRegistration(
    R.fromFn((container) => {
      const config = container.resolve('IConfig');
      return new Logger(config.logLevel);
    }).bindToKey('ILogger')
  );

const logger = container.resolve('ILogger');
expect(logger).toBeInstanceOf(Logger);`} lang="typescript" />

    <h2>Keys</h2>

    <p>
      Keys identify dependencies in the container. They can be strings, symbols,
      or tokens. Understanding how keys work is essential for effective
      dependency management.
    </p>

    <h3>Default Keys</h3>

    <p>
      When registering a class without specifying a key, the class name is used
      as the default key:
    </p>

    <CodeBlock code={`class FileLogger {}

const container = new Container()
  .addRegistration(R.fromClass(FileLogger));

// Resolve using class name
const logger = container.resolve('FileLogger');
expect(logger).toBeInstanceOf(FileLogger);`} lang="typescript" />

    <h3>Explicit Keys</h3>

    <p>
      You can specify explicit keys using <code>bindToKey()</code>:
    </p>

    <CodeBlock code={`const container = new Container()
  .addRegistration(R.fromClass(FileLogger).bindToKey('ILogger'));

const logger = container.resolve('ILogger');
expect(logger).toBeInstanceOf(FileLogger);`} lang="typescript" />

    <h3>Multiple Keys</h3>

    <p>
      You can bind a registration to multiple keys using <code>bindTo()</code>:
    </p>

    <CodeBlock code={`import { bindTo, Container, register, Registration as R, select as s } from 'ts-ioc-container';

@register(
  bindTo('ILogger'),
  bindTo(s.alias('Logger'))
)
class Logger {}

const container = new Container()
  .addRegistration(R.fromClass(Logger));

// Resolve by key
const logger1 = container.resolve('ILogger');

// Resolve by alias
const logger2 = container.resolveOneByAlias('Logger');

expect(logger1).toBeInstanceOf(Logger);
expect(logger2).toBeInstanceOf(Logger);`} lang="typescript" />

    <h3>Key Requirements</h3>

    <p>
      When registering a value or factory, you <strong>must</strong> provide a key:
    </p>

    <CodeBlock code={`import { DependencyMissingKeyError } from 'ts-ioc-container';

// This will throw DependencyMissingKeyError
expect(() => {
  container.addRegistration(R.fromValue('Hello'));
}).toThrow(DependencyMissingKeyError);

// This is correct
container.addRegistration(R.fromValue('Hello').bindToKey('greeting'));`} lang="typescript" />

    <h2>Scope Registration</h2>

    <p>
      Scope predicates control which scopes a provider is available in. This
      allows you to register different implementations for different
      environments or contexts.
    </p>

    <h3>Basic Scope Predicate</h3>

    <CodeBlock code={`import {
  bindTo,
  Container,
  register,
  Registration as R,
  scope,
  singleton,
} from 'ts-ioc-container';

@register(
  bindTo('ILogger'),
  scope((s) => s.hasTag('root')),
  singleton()
)
class Logger {}

const root = new Container({ tags: ['root'] })
  .addRegistration(R.fromClass(Logger));

// Available in root scope
expect(root.resolve('ILogger')).toBeInstanceOf(Logger);

// Not available in child scope
const child = root.createScope({ tags: ['child'] });
expect(() => child.resolve('ILogger')).toThrow();`} lang="typescript" />

    <h3>Multiple Scope Predicates</h3>

    <p>You can combine multiple scope predicates:</p>

    <CodeBlock code={`@register(
  bindTo('ILogger'),
  scope(
    (s) => s.hasTag('root'),
    (s, prev) => prev && s.hasTag('admin')
  ),
  singleton()
)
class Logger {}`} lang="typescript" />

    <h3>Fluent API Scope</h3>

    <CodeBlock code={`const container = new Container()
  .addRegistration(
    R.fromClass(Logger)
      .bindToKey('ILogger')
      .when((s) => s.hasTag('root'))
  );`} lang="typescript" />

    <h2>Registration Pipeline</h2>

    <p>
      Registrations support the pipeline pattern, allowing you to chain multiple
      transformations:
    </p>

    <CodeBlock code={`import { args, singleton, scopeAccess } from 'ts-ioc-container';

const container = new Container()
  .addRegistration(
    R.fromClass(ConfigService)
      .bindToKey('IConfig')
      .when((s) => s.hasTag('root'))
      .pipe(args('/config.json'))
      .pipe(singleton())
      .pipe(scopeAccess(({ invocationScope }) => invocationScope.hasTag('admin')))
  );`} lang="typescript" />

    <h2>Container Modules</h2>

    <p>
      Container modules encapsulate registration logic, making it easy to
      organize and compose your dependency configuration.
    </p>

    <h3>Creating a Module</h3>

    <CodeBlock code={`import {
  type IContainer,
  type IContainerModule,
  Registration as R,
} from 'ts-ioc-container';

class LoggerModule implements IContainerModule {
  applyTo(container: IContainer): void {
    container.addRegistration(R.fromClass(Logger).bindToKey('ILogger'));
    container.addRegistration(R.fromClass(FileLogger).bindToKey('IFileLogger'));
  }
}

const container = new Container()
  .useModule(new LoggerModule());

const logger = container.resolve('ILogger');
expect(logger).toBeInstanceOf(Logger);`} lang="typescript" />

    <h2>Best Practices</h2>

    <ul>
      <li>
        <strong>Use decorators for simple cases</strong> - When you have straightforward
        class registrations
      </li>
      <li>
        <strong>Use fluent API for dynamic registration</strong> - When keys or providers
        are determined at runtime
      </li>
      <li>
        <strong>Always provide keys for values/factories</strong> - Required to avoid
        errors
      </li>
      <li>
        <strong>Use modules for organization</strong> - Group related registrations
        together
      </li>
      <li>
        <strong>Use scope predicates for environment-specific code</strong> - Keep
        configurations clean
      </li>
      <li>
        <strong>Export tokens as constants</strong> - Create keys once and reuse them
      </li>
      <li>
        <strong>Use aliases for grouping</strong> - When you need multiple implementations
      </li>
    </ul>

    <h2>Registration Lifecycle</h2>

    <ol>
      <li>
        <strong>Creation</strong>: Registration is created with a provider
      </li>
      <li>
        <strong>Configuration</strong>: Keys, scopes, and features are
        configured
      </li>
      <li>
        <strong>Application</strong>: Registration is applied to container via <code
          >addRegistration()</code>
      </li>
      <li><strong>Validation</strong>: Scope predicates are evaluated</li>
      <li>
        <strong>Storage</strong>: Provider is stored in container's provider map
      </li>
      <li>
        <strong>Alias Registration</strong>: Aliases are registered if provided
      </li>
    </ol>
  </article>
</BaseLayout>

<style>
  .diagram {
    margin: 2rem 0;
    padding: 1.5rem;
    background: #f6f8fa;
    border: 1px solid #e1e4e8;
    border-radius: 8px;
    overflow-x: auto;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
  }

  .diagram .mermaid {
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 200px;
  }

  .diagram pre {
    margin: 0;
    background: transparent;
    border: none;
    padding: 0;
  }

  .diagram code {
    background: transparent;
    padding: 0;
  }
</style>
