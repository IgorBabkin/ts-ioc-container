---
import BaseLayout from '../layouts/BaseLayout.astro';
import architectureDiagram from '../diagrams/architecture-overview.mermaid?raw';
import registrationFlowDiagram from '../diagrams/registration-flow.mermaid?raw';
import classDiagram from '../diagrams/class-diagram.mermaid?raw';
import dependencyResolutionFlowDiagram from '../diagrams/dependency-resolution-flow.mermaid?raw';
import scopeHierarchyDiagram from '../diagrams/scope-hierarchy.mermaid?raw';
import providerPipelineDiagram from '../diagrams/provider-pipeline.mermaid?raw';
import injectionStrategiesDiagram from '../diagrams/injection-strategies.mermaid?raw';
---

<BaseLayout title="Design" description="Design - Architecture and design patterns of ts-ioc-container">
  <article>
    <h1>Architecture & Design</h1>
    
    <p>
      This document explains the architecture and design patterns used in <code>ts-ioc-container</code>. Understanding
      the design will help you make the most of the library and extend it for your specific needs.
    </p>

    <h2>Core Architecture</h2>
    
    <p>
      The IoC container is built on three fundamental abstractions that work together to provide dependency injection:
    </p>
    
    <ul>
      <li><strong>Container</strong>: Manages the lifecycle and resolution of dependencies</li>
      <li><strong>Provider</strong>: Factory that creates dependency instances</li>
      <li><strong>Injector</strong>: Determines how dependencies are injected into constructors</li>
      <li><strong>Registration</strong>: Connects providers to containers with keys and configuration</li>
    </ul>

    <h3>Architecture Overview</h3>
    
    <div class="diagram">
      <div class="mermaid" set:html={architectureDiagram}></div>
    </div>

    <h2>Class Diagram</h2>
    
    <p>
      The following diagram shows the main classes and interfaces and their relationships:
    </p>

    <div class="diagram">
      <div class="mermaid" set:html={classDiagram}></div>
    </div>

    <h2>Dependency Resolution Flow</h2>
    
    <p>
      The following sequence diagram illustrates how a dependency is resolved from the container:
    </p>

    <div class="diagram">
      <div class="mermaid" set:html={dependencyResolutionFlowDiagram}></div>
    </div>

    <h2>Scope Hierarchy</h2>
    
    <p>
      Containers can create child scopes, forming a tree structure. Each scope maintains its own provider registry and
      instance cache, but can fall back to parent scopes for resolution.
    </p>

    <div class="diagram">
      <div class="mermaid" set:html={scopeHierarchyDiagram}></div>
    </div>

    <h3>Scope Resolution Strategy</h3>
    
    <p>
      When resolving a dependency, the container follows this strategy:
    </p>
    
    <ol>
      <li>Check if provider exists in current scope</li>
      <li>Check if provider has access in current scope (visibility predicate)</li>
      <li>If not found, recursively check parent scopes</li>
      <li>If found in parent, check access from current scope</li>
      <li>Throw <code>DependencyNotFoundError</code> if not found anywhere</li>
    </ol>

    <h2>Provider Pipeline</h2>
    
    <p>
      Providers can be composed using the pipeline pattern. Each transformation wraps the provider with additional
      functionality:
    </p>

    <div class="diagram">
      <div class="mermaid" set:html={providerPipelineDiagram}></div>
    </div>

    <h3>Provider Composition Example</h3>
    
    <pre><code class="language-typescript">{`const provider = Provider.fromClass(Logger)
  .pipe(args('/config.json'))        // 1. Bind arguments
  .pipe(singleton())                // 2. Cache instances
  .pipe(scopeAccess(predicate))     // 3. Control visibility
  .pipe(lazy());                    // 4. Defer creation

// Each pipe wraps the previous provider
// Final provider: Lazy(Visibility(Singleton(Args(Base))))
`}</code></pre>

    <h2>Injection Strategies</h2>
    
    <p>
      The container supports three injection strategies, each implementing the <code>IInjector</code> interface:
    </p>

    <div class="diagram">
      <div class="mermaid" set:html={injectionStrategiesDiagram}></div>
    </div>

    <h2>Registration Flow</h2>
    
    <p>
      The following diagram shows how registrations are processed and applied to containers:
    </p>

    <div class="diagram">
      <div class="mermaid" set:html={registrationFlowDiagram}></div>
    </div>

    <h2>Design Patterns</h2>
    
    <h3>Strategy Pattern</h3>
    <p>
      The <code>IInjector</code> interface uses the Strategy pattern, allowing different injection strategies to be
      used interchangeably. This makes the system flexible and extensible.
    </p>

    <h3>Factory Pattern</h3>
    <p>
      Providers implement the Factory pattern, encapsulating the creation logic of dependencies. This allows for
      complex instantiation logic while keeping the container simple.
    </p>

    <h3>Decorator Pattern</h3>
    <p>
      The provider pipeline uses the Decorator pattern, allowing features to be added incrementally without
      modifying the base provider. Each pipe operation wraps the provider with additional functionality.
    </p>

    <h3>Composite Pattern</h3>
    <p>
      The scope hierarchy uses the Composite pattern, where containers can contain other containers. This allows
      uniform treatment of individual containers and container hierarchies.
    </p>

    <h3>Null Object Pattern</h3>
    <p>
      The <code>EmptyContainer</code> class implements the Null Object pattern, providing a safe default parent
      for root containers. This eliminates null checks throughout the codebase.
    </p>

    <h2>Key Design Decisions</h2>
    
    <h3>1. Separation of Concerns</h3>
    <p>
      The architecture separates three distinct responsibilities:
    </p>
    <ul>
      <li><strong>Container</strong>: Manages lifecycle and coordinates resolution</li>
      <li><strong>Provider</strong>: Handles instance creation</li>
      <li><strong>Injector</strong>: Handles dependency injection</li>
    </ul>
    <p>
      This separation makes each component testable and replaceable independently.
    </p>

    <h3>2. Scope-Based Isolation</h3>
    <p>
      Scopes provide isolation while maintaining a parent-child relationship. This design enables:
    </p>
    <ul>
      <li>Request-level isolation in web applications</li>
      <li>Feature-level separation</li>
      <li>Hierarchical dependency resolution</li>
      <li>Per-scope singleton instances</li>
    </ul>

    <h3>3. Composable Providers</h3>
    <p>
      The pipeline pattern allows providers to be composed from smaller pieces. This design:
    </p>
    <ul>
      <li>Keeps the base provider simple</li>
      <li>Allows features to be added incrementally</li>
      <li>Makes the system extensible</li>
      <li>Follows the Open/Closed Principle</li>
    </ul>

    <h3>4. Tag-Based Scoping</h3>
    <p>
      Tags provide a flexible way to control provider availability without hardcoding scope relationships. This:
    </p>
    <ul>
      <li>Enables environment-specific configurations</li>
      <li>Supports feature flags</li>
      <li>Allows dynamic scope matching</li>
      <li>Makes testing easier</li>
    </ul>

    <h2>Extension Points</h2>
    
    <p>
      The architecture provides several extension points for customization:
    </p>

    <h3>Custom Injectors</h3>
    <p>
      Implement <code>IInjector</code> to create custom injection strategies:
    </p>
    <pre><code class="language-typescript">{`class CustomInjector implements IInjector {
  resolve<T>(container: IContainer, Target: constructor<T>, options?: ProviderOptions): T {
    // Your custom injection logic
  }
}`}</code></pre>

    <h3>Custom Providers</h3>
    <p>
      Implement <code>IProvider</code> or extend <code>ProviderDecorator</code> to create custom providers:
    </p>
    <pre><code class="language-typescript">{`class CustomProvider extends ProviderDecorator {
  resolve(container: IContainer, options: ProviderOptions): T {
    // Your custom resolution logic
  }
}`}</code></pre>

    <h3>Custom Hooks</h3>
    <p>
      Create custom hooks by implementing the hook system:
    </p>
    <pre><code class="language-typescript">{`const customHookRunner = new HooksRunner('customHook');
container.addOnConstructHook((instance, scope) => {
  customHookRunner.execute(instance, { scope });
});`}</code></pre>

    <h2>Performance Considerations</h2>
    
    <h3>Singleton Caching</h3>
    <p>
      Singleton providers cache instances per scope, avoiding unnecessary object creation. The cache is implemented
      using a <code>Map</code> for O(1) lookup performance.
    </p>

    <h3>Lazy Loading</h3>
    <p>
      Lazy providers use JavaScript proxies to defer instantiation until access. This improves startup time by
      avoiding eager initialization of unused dependencies.
    </p>

    <h3>Provider Lookup</h3>
    <p>
      Providers are stored in a <code>Map</code> keyed by <code>DependencyKey</code>, providing O(1) lookup
      performance. Alias resolution uses a separate <code>AliasMap</code> for efficient multi-key lookups.
    </p>

    <h3>Scope Resolution</h3>
    <p>
      Parent scope resolution is implemented recursively but optimized to avoid deep nesting. The typical depth is
      shallow (1-3 levels), keeping resolution time constant in practice.
    </p>

    <h2>Thread Safety</h2>
    
    <p>
      <strong>Note:</strong> JavaScript is single-threaded, so thread safety is not a concern. However, the container
      is designed to be used in async contexts:
    </p>
    <ul>
      <li>Each async operation should use its own scope</li>
      <li>Scopes provide isolation between concurrent operations</li>
      <li>Instance tracking is per-scope, preventing cross-contamination</li>
    </ul>

    <h2>Memory Management</h2>
    
    <p>
      The container provides explicit disposal to prevent memory leaks:
    </p>
    <ul>
      <li><code>dispose()</code> clears all providers and instances</li>
      <li>Child scopes are automatically disposed when parent is disposed</li>
      <li>Instance tracking allows manual cleanup if needed</li>
      <li>Hooks can be used to release external resources</li>
    </ul>

    <h2>Summary</h2>
    
    <p>
      The <code>ts-ioc-container</code> architecture is designed to be:
    </p>
    <ul>
      <li><strong>Simple</strong>: Easy to understand and use</li>
      <li><strong>Flexible</strong>: Multiple injection strategies and extension points</li>
      <li><strong>Performant</strong>: Efficient lookups and lazy loading</li>
      <li><strong>Type-Safe</strong>: Full TypeScript support with inference</li>
      <li><strong>Composable</strong>: Features can be combined via pipelines</li>
      <li><strong>Extensible</strong>: Custom injectors, providers, and hooks</li>
    </ul>
  </article>
</BaseLayout>

<style>
  .diagram {
    margin: 2rem 0;
    padding: 1.5rem;
    background: #f6f8fa;
    border: 1px solid #e1e4e8;
    border-radius: 8px;
    overflow-x: auto;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
  }

  .diagram .mermaid {
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 200px;
  }

  .diagram pre {
    margin: 0;
    background: transparent;
    border: none;
    padding: 0;
  }

  .diagram code {
    background: transparent;
    padding: 0;
  }
</style>

