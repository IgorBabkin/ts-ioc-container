---
import BaseLayout from '../layouts/BaseLayout.astro';
---

<BaseLayout title="Design" description="Design - Architecture and design patterns of ts-ioc-container">
  <article>
    <h1>Architecture & Design</h1>
    
    <p>
      This document explains the architecture and design patterns used in <code>ts-ioc-container</code>. Understanding
      the design will help you make the most of the library and extend it for your specific needs.
    </p>

    <h2>Core Architecture</h2>
    
    <p>
      The IoC container is built on three fundamental abstractions that work together to provide dependency injection:
    </p>
    
    <ul>
      <li><strong>Container</strong>: Manages the lifecycle and resolution of dependencies</li>
      <li><strong>Provider</strong>: Factory that creates dependency instances</li>
      <li><strong>Injector</strong>: Determines how dependencies are injected into constructors</li>
      <li><strong>Registration</strong>: Connects providers to containers with keys and configuration</li>
    </ul>

    <h3>Architecture Overview</h3>
    
    <div class="diagram">
      <div class="mermaid">graph TB
    Container[Container]
    Provider[IProvider]
    Injector[IInjector]
    Registration[IRegistration]
    Scope[Container Scope]
    
    Container -->|uses| Provider
    Container -->|uses| Injector
    Container -->|creates| Scope
    Registration -->|creates| Provider
    Container -->|manages| Registration
    
    Provider -->|resolves| Instance[Instance]
    Injector -->|injects| Instance
    
    style Container fill:#0366d6,color:#fff
    style Provider fill:#28a745,color:#fff
    style Injector fill:#ffc107,color:#000
    style Registration fill:#17a2b8,color:#fff
    style Scope fill:#6f42c1,color:#fff
    style Instance fill:#dc3545,color:#fff</div>
    </div>

    <h2>Class Diagram</h2>
    
    <p>
      The following diagram shows the main classes and interfaces and their relationships:
    </p>

    <div class="diagram">
      <div class="mermaid">{`classDiagram
    class IContainer {
        &lt;&lt;interface&gt;&gt;
        +resolve(key) T
        +createScope(options) IContainer
        +register(key, provider) this
        +addRegistration(registration) this
        +dispose() void
        +getInstances() Instance[]
        +hasTag(tag) boolean
    }
    
    class Container {
        -parent: IContainer
        -scopes: IContainer[]
        -instances: Instance[]
        -providers: Map~DependencyKey, IProvider~
        -injector: IInjector
        -tags: Set~Tag~
        +resolve(key) T
        +createScope(options) IContainer
        +register(key, provider) this
        +dispose() void
    }
    
    class IProvider {
        &lt;&lt;interface&gt;&gt;
        +resolve(container, options) T
        +hasAccess(options) boolean
        +pipe(...mappers) IProvider
        +setAccessPredicate(fn) this
        +setArgs(fn) this
        +lazy() this
    }
    
    class Provider {
        -factory: ResolveDependency
        -argsFn: ArgsFn
        -accessPredicate: ScopeAccessFn
        -isLazy: boolean
        +resolve(container, options) T
        +pipe(...mappers) IProvider
    }
    
    class SingletonProvider {
        -cache: Cache
        +resolve(container, options) T
    }
    
    class IInjector {
        &lt;&lt;interface&gt;&gt;
        +resolve(container, constructor, options) T
    }
    
    class MetadataInjector {
        +resolve(container, constructor, options) T
        -createInstance(container, constructor, options) T
    }
    
    class SimpleInjector {
        +resolve(container, constructor, options) T
        -createInstance(container, constructor, options) T
    }
    
    class ProxyInjector {
        +resolve(container, constructor, options) T
        -createInstance(container, constructor, options) T
    }
    
    class IRegistration {
        &lt;&lt;interface&gt;&gt;
        +when(...predicates) this
        +bindToKey(key) this
        +bindTo(key) this
        +pipe(...mappers) this
        +applyTo(container) void
    }
    
    class Registration {
        -provider: IProvider
        -key: DependencyKey
        -scopePredicates: ScopePredicate[]
        +when(...predicates) this
        +bindToKey(key) this
        +applyTo(container) void
    }
    
    IContainer &lt;|.. Container
    IContainer &lt;|.. EmptyContainer
    Container --&gt; IProvider : uses
    Container --&gt; IInjector : uses
    Container --&gt; IRegistration : manages
    IProvider &lt;|.. Provider
    IProvider &lt;|.. SingletonProvider
    SingletonProvider --|&gt; Provider : extends
    IInjector &lt;|.. MetadataInjector
    IInjector &lt;|.. SimpleInjector
    IInjector &lt;|.. ProxyInjector
    IRegistration &lt;|.. Registration
    Registration --&gt; IProvider : creates
    Container --&gt; Container : parent-child`}</div>
    </div>

    <h2>Dependency Resolution Flow</h2>
    
    <p>
      The following sequence diagram illustrates how a dependency is resolved from the container:
    </p>

    <div class="diagram">
      <pre><code class="language-mermaid">sequenceDiagram
    participant Client
    participant Container
    participant Provider
    participant Injector
    participant Instance
    
    Client->>Container: resolve('ILogger')
    Container->>Container: findProvider('ILogger')
    alt Provider found in current scope
        Container->>Provider: resolve(container, options)
        Provider->>Provider: checkAccess(invocationScope)
        alt Has access
            Provider->>Provider: getArgs(container)
            Provider->>Injector: resolve(container, Logger, args)
            Injector->>Injector: createInstance(container, Logger, args)
            Injector->>Container: resolve dependencies
            Container-->>Injector: dependencies
            Injector->>Instance: new Logger(deps)
            Instance-->>Injector: instance
            Injector-->>Provider: instance
            Provider->>Provider: cache (if singleton)
            Provider-->>Container: instance
            Container->>Container: addInstance(instance)
            Container-->>Client: instance
        else No access
            Provider-->>Container: throw DependencyNotFoundError
        end
    else Provider not found
        Container->>Container: getParent()
        alt Has parent
            Container->>Container: parent.resolve('ILogger')
            Note over Container: Recursive resolution
        else No parent
            Container-->>Client: throw DependencyNotFoundError
        end
    end</div>
    </div>

    <h2>Scope Hierarchy</h2>
    
    <p>
      Containers can create child scopes, forming a tree structure. Each scope maintains its own provider registry and
      instance cache, but can fall back to parent scopes for resolution.
    </p>

    <div class="diagram">
      <div class="mermaid">graph TD
    Root[Root Container<br/>tags: 'root']
    Request1[Request Scope 1<br/>tags: 'request', 'user:123']
    Request2[Request Scope 2<br/>tags: 'request', 'user:456']
    Feature1[Feature Scope 1<br/>tags: 'feature:admin']
    Feature2[Feature Scope 2<br/>tags: 'feature:user']
    
    Root -->|createScope| Request1
    Root -->|createScope| Request2
    Request1 -->|createScope| Feature1
    Request2 -->|createScope| Feature2
    
    style Root fill:#0366d6,color:#fff
    style Request1 fill:#28a745,color:#fff
    style Request2 fill:#28a745,color:#fff
    style Feature1 fill:#ffc107,color:#000
    style Feature2 fill:#ffc107,color:#000</div>
    </div>

    <h3>Scope Resolution Strategy</h3>
    
    <p>
      When resolving a dependency, the container follows this strategy:
    </p>
    
    <ol>
      <li>Check if provider exists in current scope</li>
      <li>Check if provider has access in current scope (visibility predicate)</li>
      <li>If not found, recursively check parent scopes</li>
      <li>If found in parent, check access from current scope</li>
      <li>Throw <code>DependencyNotFoundError</code> if not found anywhere</li>
    </ol>

    <h2>Provider Pipeline</h2>
    
    <p>
      Providers can be composed using the pipeline pattern. Each transformation wraps the provider with additional
      functionality:
    </p>

    <div class="diagram">
      <div class="mermaid">graph LR
    Base[Base Provider<br/>fromClass Logger]
    Args[Args Provider<br/>args '/config.json']
    Singleton[Singleton Provider<br/>cache instance]
    Visibility[Visibility Provider<br/>scopeAccess predicate]
    Lazy[Lazy Provider<br/>deferred creation]
    
    Base -->|pipe args| Args
    Args -->|pipe singleton| Singleton
    Singleton -->|pipe scopeAccess| Visibility
    Visibility -->|pipe lazy| Lazy
    
    Lazy -->|final| Final[Final Provider]
    
    style Base fill:#e1e4e8
    style Args fill:#c6e48b
    style Singleton fill:#7bc96f
    style Visibility fill:#239a3b
    style Lazy fill:#196127
    style Final fill:#0366d6,color:#fff</div>
    </div>

    <h3>Provider Composition Example</h3>
    
    <pre><code class="language-typescript">{`const provider = Provider.fromClass(Logger)
  .pipe(args('/config.json'))        // 1. Bind arguments
  .pipe(singleton())                // 2. Cache instances
  .pipe(scopeAccess(predicate))     // 3. Control visibility
  .pipe(lazy());                    // 4. Defer creation

// Each pipe wraps the previous provider
// Final provider: Lazy(Visibility(Singleton(Args(Base))))
`}</code></pre>

    <h2>Injection Strategies</h2>
    
    <p>
      The container supports three injection strategies, each implementing the <code>IInjector</code> interface:
    </p>

    <div class="diagram">
      <div class="mermaid">graph TB
    IInjector[IInjector Interface]
    Metadata[MetadataInjector<br/>Uses @inject decorators<br/>+ reflect-metadata]
    Simple[SimpleInjector<br/>Passes container<br/>as first arg]
    Proxy[ProxyInjector<br/>Matches param names<br/>to dependency keys]
    
    IInjector <|.. Metadata
    IInjector <|.. Simple
    IInjector <|.. Proxy
    
    Metadata -->|injects| Instance1[Instance with<br/>decorated params]
    Simple -->|injects| Instance2[Instance with<br/>container param]
    Proxy -->|injects| Instance3[Instance with<br/>destructured params]
    
    style IInjector fill:#0366d6,color:#fff
    style Metadata fill:#28a745,color:#fff
    style Simple fill:#ffc107,color:#000
    style Proxy fill:#17a2b8,color:#fff</div>
    </div>

    <h2>Registration Flow</h2>
    
    <p>
      The following diagram shows how registrations are processed and applied to containers:
    </p>

    <div class="diagram">
      <pre><code class="language-mermaid">sequenceDiagram
    participant Dev as Developer
    participant Reg as Registration
    participant Container
    participant Provider
    participant AliasMap
    
    Dev->>Reg: Registration.fromClass(Logger)
    Reg->>Reg: create Provider
    Dev->>Reg: bindToKey('ILogger')
    Reg->>Reg: set key = 'ILogger'
    Dev->>Reg: pipe(singleton())
    Reg->>Provider: pipe(singleton())
    Provider->>Provider: wrap with SingletonProvider
    Dev->>Reg: when(scope => scope.hasTag('root'))
    Reg->>Reg: add scope predicate
    Dev->>Container: addRegistration(registration)
    Container->>Reg: applyTo(container)
    Reg->>Reg: check scope predicates
    alt Scope matches
        Reg->>Container: register('ILogger', provider)
        Container->>Provider: store in providers map
        Reg->>Container: bindToAlias('Logger')
        Container->>AliasMap: add('Logger', 'ILogger')
        Container-->>Dev: registration complete
    else Scope doesn't match
        Reg-->>Container: skip registration
    end</div>
    </div>

    <h2>Design Patterns</h2>
    
    <h3>Strategy Pattern</h3>
    <p>
      The <code>IInjector</code> interface uses the Strategy pattern, allowing different injection strategies to be
      used interchangeably. This makes the system flexible and extensible.
    </p>

    <h3>Factory Pattern</h3>
    <p>
      Providers implement the Factory pattern, encapsulating the creation logic of dependencies. This allows for
      complex instantiation logic while keeping the container simple.
    </p>

    <h3>Decorator Pattern</h3>
    <p>
      The provider pipeline uses the Decorator pattern, allowing features to be added incrementally without
      modifying the base provider. Each pipe operation wraps the provider with additional functionality.
    </p>

    <h3>Composite Pattern</h3>
    <p>
      The scope hierarchy uses the Composite pattern, where containers can contain other containers. This allows
      uniform treatment of individual containers and container hierarchies.
    </p>

    <h3>Null Object Pattern</h3>
    <p>
      The <code>EmptyContainer</code> class implements the Null Object pattern, providing a safe default parent
      for root containers. This eliminates null checks throughout the codebase.
    </p>

    <h2>Key Design Decisions</h2>
    
    <h3>1. Separation of Concerns</h3>
    <p>
      The architecture separates three distinct responsibilities:
    </p>
    <ul>
      <li><strong>Container</strong>: Manages lifecycle and coordinates resolution</li>
      <li><strong>Provider</strong>: Handles instance creation</li>
      <li><strong>Injector</strong>: Handles dependency injection</li>
    </ul>
    <p>
      This separation makes each component testable and replaceable independently.
    </p>

    <h3>2. Scope-Based Isolation</h3>
    <p>
      Scopes provide isolation while maintaining a parent-child relationship. This design enables:
    </p>
    <ul>
      <li>Request-level isolation in web applications</li>
      <li>Feature-level separation</li>
      <li>Hierarchical dependency resolution</li>
      <li>Per-scope singleton instances</li>
    </ul>

    <h3>3. Composable Providers</h3>
    <p>
      The pipeline pattern allows providers to be composed from smaller pieces. This design:
    </p>
    <ul>
      <li>Keeps the base provider simple</li>
      <li>Allows features to be added incrementally</li>
      <li>Makes the system extensible</li>
      <li>Follows the Open/Closed Principle</li>
    </ul>

    <h3>4. Tag-Based Scoping</h3>
    <p>
      Tags provide a flexible way to control provider availability without hardcoding scope relationships. This:
    </p>
    <ul>
      <li>Enables environment-specific configurations</li>
      <li>Supports feature flags</li>
      <li>Allows dynamic scope matching</li>
      <li>Makes testing easier</li>
    </ul>

    <h2>Extension Points</h2>
    
    <p>
      The architecture provides several extension points for customization:
    </p>

    <h3>Custom Injectors</h3>
    <p>
      Implement <code>IInjector</code> to create custom injection strategies:
    </p>
    <pre><code class="language-typescript">{`class CustomInjector implements IInjector {
  resolve<T>(container: IContainer, Target: constructor<T>, options?: ProviderOptions): T {
    // Your custom injection logic
  }
}`}</code></pre>

    <h3>Custom Providers</h3>
    <p>
      Implement <code>IProvider</code> or extend <code>ProviderDecorator</code> to create custom providers:
    </p>
    <pre><code class="language-typescript">{`class CustomProvider extends ProviderDecorator {
  resolve(container: IContainer, options: ProviderOptions): T {
    // Your custom resolution logic
  }
}`}</code></pre>

    <h3>Custom Hooks</h3>
    <p>
      Create custom hooks by implementing the hook system:
    </p>
    <pre><code class="language-typescript">{`const customHookRunner = new HooksRunner('customHook');
container.addOnConstructHook((instance, scope) => {
  customHookRunner.execute(instance, { scope });
});`}</code></pre>

    <h2>Performance Considerations</h2>
    
    <h3>Singleton Caching</h3>
    <p>
      Singleton providers cache instances per scope, avoiding unnecessary object creation. The cache is implemented
      using a <code>Map</code> for O(1) lookup performance.
    </p>

    <h3>Lazy Loading</h3>
    <p>
      Lazy providers use JavaScript proxies to defer instantiation until access. This improves startup time by
      avoiding eager initialization of unused dependencies.
    </p>

    <h3>Provider Lookup</h3>
    <p>
      Providers are stored in a <code>Map</code> keyed by <code>DependencyKey</code>, providing O(1) lookup
      performance. Alias resolution uses a separate <code>AliasMap</code> for efficient multi-key lookups.
    </p>

    <h3>Scope Resolution</h3>
    <p>
      Parent scope resolution is implemented recursively but optimized to avoid deep nesting. The typical depth is
      shallow (1-3 levels), keeping resolution time constant in practice.
    </p>

    <h2>Thread Safety</h2>
    
    <p>
      <strong>Note:</strong> JavaScript is single-threaded, so thread safety is not a concern. However, the container
      is designed to be used in async contexts:
    </p>
    <ul>
      <li>Each async operation should use its own scope</li>
      <li>Scopes provide isolation between concurrent operations</li>
      <li>Instance tracking is per-scope, preventing cross-contamination</li>
    </ul>

    <h2>Memory Management</h2>
    
    <p>
      The container provides explicit disposal to prevent memory leaks:
    </p>
    <ul>
      <li><code>dispose()</code> clears all providers and instances</li>
      <li>Child scopes are automatically disposed when parent is disposed</li>
      <li>Instance tracking allows manual cleanup if needed</li>
      <li>Hooks can be used to release external resources</li>
    </ul>

    <h2>Summary</h2>
    
    <p>
      The <code>ts-ioc-container</code> architecture is designed to be:
    </p>
    <ul>
      <li><strong>Simple</strong>: Easy to understand and use</li>
      <li><strong>Flexible</strong>: Multiple injection strategies and extension points</li>
      <li><strong>Performant</strong>: Efficient lookups and lazy loading</li>
      <li><strong>Type-Safe</strong>: Full TypeScript support with inference</li>
      <li><strong>Composable</strong>: Features can be combined via pipelines</li>
      <li><strong>Extensible</strong>: Custom injectors, providers, and hooks</li>
    </ul>
  </article>
</BaseLayout>

<style>
  .diagram {
    margin: 2rem 0;
    padding: 1.5rem;
    background: #f6f8fa;
    border: 1px solid #e1e4e8;
    border-radius: 8px;
    overflow-x: auto;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
  }

  .diagram .mermaid {
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 200px;
  }

  .diagram pre {
    margin: 0;
    background: transparent;
    border: none;
    padding: 0;
  }

  .diagram code {
    background: transparent;
    padding: 0;
  }
</style>

