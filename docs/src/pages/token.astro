---
import BaseLayout from "../layouts/BaseLayout.astro";
import CodeBlock from "../components/CodeBlock.astro";
import tokenHierarchyDiagram from "../diagrams/token-hierarchy.mermaid?raw";
---

<BaseLayout
  title="Token"
  description="Token - Token types for dependency keys (InjectionToken, SingleToken, GroupAliasToken, etc.)"
>
  <article>
    <h1>Token</h1>

    <p>
      Tokens are used to identify and resolve dependencies in the container. The
      library provides several token types for different use cases, each
      offering different levels of type safety and flexibility.
    </p>

    <h2 id="why-tokens">Why Tokens?</h2>

    <p>
      While you can use plain strings or symbols as dependency keys, tokens
      provide additional benefits:
    </p>

    <ul>
      <li>
        <strong>Type Safety</strong>: Tokens carry type information, improving
        IntelliSense and compile-time checks
      </li>
      <li>
        <strong>Uniqueness</strong>: Tokens ensure unique identification,
        preventing accidental key collisions
      </li>
      <li>
        <strong>Features</strong>: Some tokens support additional features like
        argument binding and lazy loading
      </li>
      <li>
        <strong>Refactoring</strong>: Tokens make refactoring safer by providing
        a single source of truth
      </li>
    </ul>

    <h2 id="token-hierarchy">Token Hierarchy</h2>

    <p>
      All tokens in the library extend the abstract <code>InjectionToken</code> base class,
      which defines the common interface for dependency resolution. The following diagram
      shows the inheritance hierarchy and relationships between different token types:
    </p>

    <div class="diagram">
      <div class="mermaid" set:html={tokenHierarchyDiagram}></div>
    </div>

    <p>
      <strong>Key Points:</strong>
    </p>
    <ul>
      <li>
        <code>InjectionToken</code> is the abstract base class that all tokens extend
      </li>
      <li>
        <code>SingleToken</code> is a concrete implementation for simple dependency keys
      </li>
      <li>
        <code>GroupAliasToken</code> extends <code>InjectionToken</code> for grouping multiple implementations (resolves to array)
      </li>
      <li>
        <code>SingleAliasToken</code> extends <code>InjectionToken</code> for grouping implementations (resolves to single instance)
      </li>
    </ul>

    <h2 id="single-token">SingleToken</h2>

    <p>
      <code>SingleToken</code> is a simple token that wraps a string or symbol key. It
      provides type safety while maintaining simplicity.
    </p>

    <CodeBlock code={`import { SingleToken, Container, inject, Registration as R } from 'ts-ioc-container';

interface ILogger {
  log(message: string): void;
}

const ILoggerKey = new SingleToken<ILogger>('ILogger');

class Logger implements ILogger {
  log(message: string) {
    console.log(message);
  }
}

class App {
  constructor(@inject(ILoggerKey) private logger: ILogger) {}
}

const container = new Container()
  .addRegistration(R.fromClass(Logger).bindToKey(ILoggerKey));

const app = container.resolve(App);
app.logger.log('Hello');`} lang="typescript" />

    <h2 id="group-alias-token">GroupAliasToken</h2>

    <p>
      <code>GroupAliasToken</code> is used to group multiple registrations under a common
      alias. This is perfect for plugin systems or middleware. It resolves to an array
      of all implementations bound to the alias.
    </p>

    <CodeBlock code={`import {
  GroupAliasToken,
  Container,
  inject,
  register,
  Registration as R,
  select as s,
} from 'ts-ioc-container';

const IMiddlewareToken = new GroupAliasToken('IMiddleware');

interface IMiddleware {
  apply(): void;
}

@register(bindTo(s.alias(IMiddlewareToken)))
class LoggerMiddleware implements IMiddleware {
  apply() {
    console.log('Logger middleware');
  }
}

@register(bindTo(s.alias(IMiddlewareToken)))
class AuthMiddleware implements IMiddleware {
  apply() {
    console.log('Auth middleware');
  }
}

class App {
  constructor(@inject(s.alias(IMiddlewareToken)) public middleware: IMiddleware[]) {}
  
  run() {
    this.middleware.forEach(m => m.apply());
  }
}

const container = new Container()
  .addRegistration(R.fromClass(LoggerMiddleware))
  .addRegistration(R.fromClass(AuthMiddleware));

const app = container.resolve(App);
app.run(); // Both middleware are applied`} lang="typescript" />

    <h2 id="single-alias-token">SingleAliasToken</h2>

    <p>
      <code>SingleAliasToken</code> is similar to <code>GroupAliasToken</code>, but resolves
      to a single instance instead of an array. This is useful when you want to ensure
      only one implementation is resolved from an alias, or when you have a default
      implementation that should be used when multiple are registered.
    </p>

    <CodeBlock code={`import {
  SingleAliasToken,
  Container,
  inject,
  Registration as R,
  toSingleAlias,
} from 'ts-ioc-container';

const ILoggerToken = new SingleAliasToken<ILogger>('ILogger');

interface ILogger {
  log(message: string): void;
}

class ConsoleLogger implements ILogger {
  log(message: string) {
    console.log(message);
  }
}

class FileLogger implements ILogger {
  log(message: string) {
    // Write to file
  }
}

class App {
  constructor(@inject(ILoggerToken) private logger: ILogger) {}
  
  run() {
    this.logger.log('Hello'); // Uses one of the registered loggers
  }
}

const container = new Container()
  .addRegistration(R.fromClass(ConsoleLogger).bindToKey('ConsoleLogger').bindToAlias('ILogger'))
  .addRegistration(R.fromClass(FileLogger).bindToKey('FileLogger').bindToAlias('ILogger'));

const app = container.resolve(App);
app.run();

// You can also use the helper function
const ILoggerToken2 = toSingleAlias<ILogger>('ILogger');`} lang="typescript" />

    <h2 id="argument-binding">Argument Binding</h2>

    <p>
      Tokens support argument binding, allowing you to pass arguments when
      resolving:
    </p>

    <CodeBlock code={`const IConfigKey = new InjectionToken<IConfig>('IConfig');

class App {
  constructor(
    @inject(toToken('IConfig').args({ apiUrl: 'https://api.example.com', timeout: 5000 }))
    private config: IConfig
  ) {}
}`} lang="typescript" />

    <h2 id="lazy-loading">Lazy Loading</h2>

    <p>Tokens support lazy loading, deferring instantiation until access:</p>

    <CodeBlock code={`class App {
  constructor(
    @inject(toToken('IConfig').lazy())
    private config: IConfig
  ) {}
}`} lang="typescript" />

    <h2 id="dynamic-arguments">Dynamic Arguments</h2>

    <p>Tokens support dynamic argument resolution using functions:</p>

    <CodeBlock code={`class App {
  constructor(
    @inject(
      toToken('IConfig').argsFn((scope) => [
        { apiUrl: scope.resolve('API_URL'), timeout: 5000 }
      ])
    )
    private config: IConfig
  ) {}
}`} lang="typescript" />

  </article>
</BaseLayout>

