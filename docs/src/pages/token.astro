---
import BaseLayout from "../layouts/BaseLayout.astro";
import CodeBlock from "../components/CodeBlock.astro";
import tokenHierarchyDiagram from "../diagrams/token-hierarchy.mermaid?raw";
import tokenSpecCode from "../../../__tests__/readme/token.spec.ts?raw";
import tokenGroupAliasSpecCode from "../../../__tests__/readme/tokenGroupAlias.spec.ts?raw";
import tokenSingleAliasSpecCode from "../../../__tests__/readme/tokenSingleAlias.spec.ts?raw";
import tokenArgsSpecCode from "../../../__tests__/readme/tokenArgs.spec.ts?raw";
import tokenLazySpecCode from "../../../__tests__/readme/tokenLazy.spec.ts?raw";
import tokenArgsFnSpecCode from "../../../__tests__/readme/tokenArgsFn.spec.ts?raw";
---

<BaseLayout
  title="Token"
  description="Token - Token types for dependency keys (InjectionToken, SingleToken, GroupAliasToken, etc.)"
>
  <article>
    <h1>Token</h1>

    <p>
      Tokens are used to identify and resolve dependencies in the container. The
      library provides several token types for different use cases, each
      offering different levels of type safety and flexibility.
    </p>

    <h2 id="why-tokens">Why Tokens?</h2>

    <p>
      While you can use plain strings or symbols as dependency keys, tokens
      provide additional benefits:
    </p>

    <ul>
      <li>
        <strong>Type Safety</strong>: Tokens carry type information, improving
        IntelliSense and compile-time checks
      </li>
      <li>
        <strong>Uniqueness</strong>: Tokens ensure unique identification,
        preventing accidental key collisions
      </li>
      <li>
        <strong>Features</strong>: Some tokens support additional features like
        argument binding and lazy loading
      </li>
      <li>
        <strong>Refactoring</strong>: Tokens make refactoring safer by providing
        a single source of truth
      </li>
    </ul>

    <h2 id="token-hierarchy">Token Hierarchy</h2>

    <p>
      All tokens in the library extend the abstract <code>InjectionToken</code> base class,
      which defines the common interface for dependency resolution. The following diagram
      shows the inheritance hierarchy and relationships between different token types:
    </p>

    <div class="diagram">
      <div class="mermaid" set:html={tokenHierarchyDiagram}></div>
    </div>

    <p>
      <strong>Key Points:</strong>
    </p>
    <ul>
      <li>
        <code>InjectionToken</code> is the abstract base class that all tokens extend
      </li>
      <li>
        <code>SingleToken</code> is a concrete implementation for simple dependency keys
      </li>
      <li>
        <code>GroupAliasToken</code> extends <code>InjectionToken</code> for grouping multiple implementations (resolves to array)
      </li>
      <li>
        <code>SingleAliasToken</code> extends <code>InjectionToken</code> for grouping implementations (resolves to single instance)
      </li>
    </ul>

    <h2 id="single-token">SingleToken</h2>

    <p>
      <code>SingleToken</code> is a simple token that wraps a string or symbol key. It
      provides type safety while maintaining simplicity.
    </p>

    <CodeBlock code={tokenSpecCode} lang="typescript" filename="__tests__/readme/token.spec.ts" />

    <h2 id="group-alias-token">GroupAliasToken</h2>

    <p>
      <code>GroupAliasToken</code> is used to group multiple registrations under a common
      alias. This is perfect for plugin systems or middleware. It resolves to an array
      of all implementations bound to the alias.
    </p>

    <CodeBlock code={tokenGroupAliasSpecCode} lang="typescript" filename="__tests__/readme/tokenGroupAlias.spec.ts" />

    <h2 id="single-alias-token">SingleAliasToken</h2>

    <p>
      <code>SingleAliasToken</code> is similar to <code>GroupAliasToken</code>, but resolves
      to a single instance instead of an array. This is useful when you want to ensure
      only one implementation is resolved from an alias, or when you have a default
      implementation that should be used when multiple are registered.
    </p>

    <CodeBlock code={tokenSingleAliasSpecCode} lang="typescript" filename="__tests__/readme/tokenSingleAlias.spec.ts" />

    <h2 id="argument-binding">Argument Binding</h2>

    <p>
      Tokens support argument binding, allowing you to pass arguments when
      resolving:
    </p>

    <CodeBlock code={tokenArgsSpecCode} lang="typescript" filename="__tests__/readme/tokenArgs.spec.ts" />

    <h2 id="lazy-loading">Lazy Loading</h2>

    <p>Tokens support lazy loading, deferring instantiation until access:</p>

    <CodeBlock code={tokenLazySpecCode} lang="typescript" filename="__tests__/readme/tokenLazy.spec.ts" />

    <h2 id="dynamic-arguments">Dynamic Arguments</h2>

    <p>Tokens support dynamic argument resolution using functions:</p>

    <CodeBlock code={tokenArgsFnSpecCode} lang="typescript" filename="__tests__/readme/tokenArgsFn.spec.ts" />

  </article>
</BaseLayout>

