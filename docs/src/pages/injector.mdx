---
layout: ../layouts/BaseLayout.astro
title: Injector
description: Injector - Different injection strategies (Metadata, Simple, Proxy)
---

import CodeBlock from "../components/CodeBlock.astro";
import injectionStrategiesDiagram from "../diagrams/injection-strategies.mermaid?raw";
import metadataInjectorSpecCode from "../../../__tests__/readme/metadataInjector.spec.ts?raw";
import simpleInjectorSpecCode from "../../../__tests__/injector/SimpleInjector.spec.ts?raw";
import proxyInjectorSpecCode from "../../../__tests__/injector/ProxyInjector.spec.ts?raw";
import customInjectorSpecCode from "../../../__tests__/readme/customInjector.spec.ts?raw";

# Injector

<p>
  The injector determines how dependencies are passed to constructors. The
  container supports three injection strategies, each suited for different
  use cases and coding styles.
</p>

<h2 id="injection-strategies">Injection Strategies</h2>

<p>
  The container supports three injection strategies, each implementing the <code>IInjector</code> interface:
</p>

<div class="diagram">
  <div class="mermaid" set:html={injectionStrategiesDiagram} />
</div>

<h2 id="available-injectors">Available Injectors</h2>

<ul>
  <li>
    <strong>MetadataInjector</strong> (default): Uses <code>@inject</code> decorators
    with reflection metadata
  </li>
  <li>
    <strong>ProxyInjector</strong>: Injects dependencies as a dictionary
    object, perfect for destructuring
  </li>
  <li>
    <strong>SimpleInjector</strong>: Passes the container as the first
    constructor argument for manual resolution
  </li>
</ul>

<h2 id="metadata-injector">Metadata Injector</h2>

<p>
  The default injector uses TypeScript decorators and reflection metadata to
  inject dependencies. This provides a clean, declarative syntax that's easy
  to read and maintain.
</p>

### Basic Usage

<CodeBlock
  code={metadataInjectorSpecCode}
  lang="typescript"
  filename="__tests__/readme/metadataInjector.spec.ts"
/>

### Property Injection

<p>
  The Metadata Injector also supports property injection using hooks. This
  is useful when constructor injection isn't possible or when you need to
  inject into base class properties. See the <a href="/ts-ioc-container/hooks#property-injection">Hooks</a> chapter
  for detailed information about property injection.
</p>


<h2 id="simple-injector">Simple Injector</h2>

<p>
  The Simple Injector passes the container instance as the first constructor
  parameter, giving you direct access to resolve dependencies manually. This
  approach is useful when you need more control over dependency resolution.
</p>

<CodeBlock
  code={simpleInjectorSpecCode}
  lang="typescript"
  filename="__tests__/injector/SimpleInjector.spec.ts"
/>

### Use Cases
<ul>
  <li>Manual dependency resolution</li>
  <li>Dynamic dependency selection</li>
  <li>Legacy code integration</li>
  <li>Framework integration where container access is needed</li>
</ul>

<h2 id="proxy-injector">Proxy Injector</h2>

<p>
  The Proxy Injector matches constructor parameter names to dependency keys
  and injects them as a dictionary object. This is useful for object
  destructuring patterns and functional programming styles.
</p>

<CodeBlock
  code={proxyInjectorSpecCode}
  lang="typescript"
  filename="__tests__/injector/ProxyInjector.spec.ts"
/>

### Use Cases
<ul>
  <li>Object destructuring in constructors</li>
  <li>Named parameter patterns</li>
  <li>Functional programming styles</li>
  <li>When you prefer explicit parameter names over decorators</li>
</ul>

<h2 id="choosing-the-right-injector">Choosing the Right Injector</h2>

<div class="table-responsive mb-4">
  <table class="table table-striped table-hover">
    <thead>
      <tr>
        <th>Injector</th>
        <th>Best For</th>
        <th>Pros</th>
        <th>Cons</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><strong>MetadataInjector</strong></td>
        <td>Most applications, TypeScript projects</td>
        <td>Clean syntax, type-safe, IntelliSense support</td>
        <td>Requires reflect-metadata, decorator support</td>
      </tr>
      <tr>
        <td><strong>SimpleInjector</strong></td>
        <td>Manual control, legacy code, frameworks</td>
        <td>Full control, no decorators needed</td>
        <td>More verbose, manual resolution</td>
      </tr>
      <tr>
        <td><strong>ProxyInjector</strong></td>
        <td>Destructuring patterns, functional style</td>
        <td>Explicit parameter names, no decorators</td>
        <td>Less type inference, naming conventions</td>
      </tr>
    </tbody>
  </table>
</div>

<h2 id="strategy-pattern">Strategy Pattern</h2>
<p>
  The <code>IInjector</code> interface uses the Strategy pattern, allowing different
  injection strategies to be used interchangeably. This makes the system flexible
  and extensible.
</p>

<h2 id="custom-injectors">Custom Injectors</h2>

<p>
  You can create custom injectors by implementing the <code>Injector</code> interface.
  This allows you to implement injection strategies tailored to your specific
  needs.
</p>

<CodeBlock
  code={customInjectorSpecCode}
  lang="typescript"
  filename="__tests__/readme/customInjector.spec.ts"
/>

### Extension Points
<p>
  Custom injectors are one of the key extension points in the architecture.
  They allow you to:
</p>
<ul>
  <li>Implement framework-specific injection patterns</li>
  <li>Add custom parameter resolution logic</li>
  <li>Integrate with legacy codebases</li>
  <li>Support alternative dependency injection styles</li>
</ul>

<h2 id="best-practices">Best Practices</h2>

<ul>
  <li>
    <strong>Use MetadataInjector by default</strong> - It provides the best developer
    experience for most TypeScript projects
  </li>
  <li>
    <strong>Choose SimpleInjector for manual control</strong> - When you need
    explicit control over dependency resolution
  </li>
  <li>
    <strong>Use ProxyInjector for destructuring</strong> - When you prefer object
    destructuring patterns
  </li>
  <li>
    <strong>Be consistent</strong> - Stick with one injector strategy throughout
    your application for maintainability
  </li>
</ul>