---
layout: ../layouts/BaseLayout.astro
title: Injector
description: Injector - Different injection strategies (Metadata, Simple, Proxy)
---

import CodeBlock from "../components/CodeBlock.astro";
import injectionStrategiesDiagram from "../diagrams/injection-strategies.mermaid?raw";
import metadataInjectorSpecCode from "../../../__tests__/readme/metadataInjector.spec.ts?raw";
import simpleInjectorSpecCode from "../../../__tests__/injector/SimpleInjector.spec.ts?raw";
import proxyInjectorSpecCode from "../../../__tests__/injector/ProxyInjector.spec.ts?raw";
import customInjectorSpecCode from "../../../__tests__/readme/customInjector.spec.ts?raw";

# Injector

The injector determines how dependencies are passed to constructors. The container supports three injection strategies, each suited for different use cases and coding styles.

<h2 id="injection-strategies">Injection Strategies</h2>

The container supports three injection strategies, each implementing the `IInjector` interface:

<div class="diagram">
  <div class="mermaid" set:html={injectionStrategiesDiagram} />
</div>

<h2 id="available-injectors">Available Injectors</h2>

- **MetadataInjector** (default): Uses `@inject` decorators with reflection metadata
- **ProxyInjector**: Injects dependencies as a dictionary object, perfect for destructuring
- **SimpleInjector**: Passes the container as the first constructor argument for manual resolution

<h2 id="metadata-injector">Metadata Injector</h2>

The default injector uses TypeScript decorators and reflection metadata to inject dependencies. This provides a clean, declarative syntax that's easy to read and maintain.

### Basic Usage

<CodeBlock
  code={metadataInjectorSpecCode}
  lang="typescript"
  filename="__tests__/readme/metadataInjector.spec.ts"
/>

### Property Injection

The Metadata Injector also supports property injection using hooks. This is useful when constructor injection isn't possible or when you need to inject into base class properties. See the [Hooks](/ts-ioc-container/hooks#property-injection) chapter for detailed information about property injection.

<h2 id="simple-injector">Simple Injector</h2>

The Simple Injector passes the container instance as the first constructor parameter, giving you direct access to resolve dependencies manually. This approach is useful when you need more control over dependency resolution.

<CodeBlock
  code={simpleInjectorSpecCode}
  lang="typescript"
  filename="__tests__/injector/SimpleInjector.spec.ts"
/>

### Use Cases

- Manual dependency resolution
- Dynamic dependency selection
- Legacy code integration
- Framework integration where container access is needed

<h2 id="proxy-injector">Proxy Injector</h2>

The Proxy Injector matches constructor parameter names to dependency keys and injects them as a dictionary object. This is useful for object destructuring patterns and functional programming styles.

<CodeBlock
  code={proxyInjectorSpecCode}
  lang="typescript"
  filename="__tests__/injector/ProxyInjector.spec.ts"
/>

### Use Cases

- Object destructuring in constructors
- Named parameter patterns
- Functional programming styles
- When you prefer explicit parameter names over decorators

<h2 id="choosing-the-right-injector">Choosing the Right Injector</h2>

<div class="table-responsive mb-4">
  <table class="table table-striped table-hover">
    <thead>
      <tr>
        <th>Injector</th>
        <th>Best For</th>
        <th>Pros</th>
        <th>Cons</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><strong>MetadataInjector</strong></td>
        <td>Most applications, TypeScript projects</td>
        <td>Clean syntax, type-safe, IntelliSense support</td>
        <td>Requires reflect-metadata, decorator support</td>
      </tr>
      <tr>
        <td><strong>SimpleInjector</strong></td>
        <td>Manual control, legacy code, frameworks</td>
        <td>Full control, no decorators needed</td>
        <td>More verbose, manual resolution</td>
      </tr>
      <tr>
        <td><strong>ProxyInjector</strong></td>
        <td>Destructuring patterns, functional style</td>
        <td>Explicit parameter names, no decorators</td>
        <td>Less type inference, naming conventions</td>
      </tr>
    </tbody>
  </table>
</div>

<h2 id="strategy-pattern">Strategy Pattern</h2>

The `IInjector` interface uses the Strategy pattern, allowing different injection strategies to be used interchangeably. This makes the system flexible and extensible.

<h2 id="custom-injectors">Custom Injectors</h2>

You can create custom injectors by implementing the `Injector` interface. This allows you to implement injection strategies tailored to your specific needs.

<CodeBlock
  code={customInjectorSpecCode}
  lang="typescript"
  filename="__tests__/readme/customInjector.spec.ts"
/>

### Extension Points

Custom injectors are one of the key extension points in the architecture. They allow you to:

- Implement framework-specific injection patterns
- Add custom parameter resolution logic
- Integrate with legacy codebases
- Support alternative dependency injection styles

<h2 id="best-practices">Best Practices</h2>

- **Use MetadataInjector by default** - It provides the best developer experience for most TypeScript projects
- **Choose SimpleInjector for manual control** - When you need explicit control over dependency resolution
- **Use ProxyInjector for destructuring** - When you prefer object destructuring patterns
- **Be consistent** - Stick with one injector strategy throughout your application for maintainability