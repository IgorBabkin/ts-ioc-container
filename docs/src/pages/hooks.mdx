---
layout: ../layouts/BaseLayout.astro
title: Hooks
description: Hooks - Lifecycle hooks for instance initialization and cleanup (onConstruct, onDispose)
---

import CodeBlock from "../components/CodeBlock.astro";
import injectPropSpecCode from "../../../__tests__/readme/injectProp.spec.ts?raw";
import onConstructSpecCode from "../../../__tests__/hooks/OnConstruct.spec.ts?raw";
import onDisposeSpecCode from "../../../__tests__/hooks/OnDispose.spec.ts?raw";
import hookSpecCode from "../../../__tests__/hooks/hook.spec.ts?raw";
import customHooksSpecCode from "../../../__tests__/readme/customHooks.spec.ts?raw";

# Hooks

Hooks provide a way to execute code at specific lifecycle points of an instance. They enable initialization logic after construction, cleanup logic before disposal, property injection, and custom lifecycle management. The hook system is flexible and extensible, allowing you to create custom hooks for your specific needs.

## What are Hooks?

Hooks are methods decorated with special decorators that execute at specific points in an instance's lifecycle. They can:

- Run initialization code after instance construction
- Execute cleanup logic before instance disposal
- Inject dependencies into properties
- Perform custom lifecycle operations

The hook system uses `HooksRunner` to execute hooks, which can be synchronous or asynchronous. Hooks can resolve dependencies from the container, making them powerful tools for managing complex initialization scenarios.

## OnConstruct Hooks

OnConstruct hooks execute after an instance is created. This is useful for initialization logic that needs access to the container or other dependencies that can't be injected via the constructor.

### Basic Usage

Register an onConstruct hook on your container, then decorate methods with `@onConstruct`:

<CodeBlock
  code={onConstructSpecCode}
  lang="typescript"
  filename="__tests__/hooks/OnConstruct.spec.ts"
/>

### Use Cases

- **DatabaseConnection** - Establish connection after service is created
- **SessionManager** - Load user session from Redis after construction
- **CacheService** - Warm up cache with frequently accessed data
- **EmailNotifier** - Validate SMTP configuration before first use

## OnDispose Hooks

OnDispose hooks execute before an instance is disposed, allowing you to clean up resources, save state, or perform other cleanup operations.

### Basic Usage

Register an onDispose hook on your container, then decorate methods with `@onDispose`:

<CodeBlock
  code={onDisposeSpecCode}
  lang="typescript"
  filename="__tests__/hooks/OnDispose.spec.ts"
/>

### Use Cases

- **DatabaseConnection** - Return connection to pool when request ends
- **SessionManager** - Persist session changes to Redis before disposal
- **FileUploadService** - Clean up temporary uploaded files
- **WebSocketHandler** - Close WebSocket connections gracefully
- **AuditLogger** - Flush pending audit log entries

## Property Injection

Property injection allows you to inject dependencies into properties using hooks. This is useful when constructor injection isn't possible or when you need to inject into base class properties.

### Using injectProp with Hooks

The `injectProp` helper can be used with the `@hook` decorator to inject dependencies into properties:

<CodeBlock
  code={injectPropSpecCode}
  lang="typescript"
  filename="__tests__/readme/injectProp.spec.ts"
/>

### When to Use Property Injection

- Injecting into base class properties
- Optional dependencies that might not always be available
- Circular dependency scenarios
- Framework integration where constructor injection is limited

## Custom Hooks

You can create custom hooks for any lifecycle event or application-specific scenario. Custom hooks use the same `HooksRunner` system but with your own hook names.

### Creating Custom Hooks

Create a custom hook by instantiating a `HooksRunner` with a unique hook name:

<CodeBlock
  code={customHooksSpecCode}
  lang="typescript"
  filename="__tests__/readme/customHooks.spec.ts"
/>

### Synchronous vs Asynchronous Hooks

Hooks can be synchronous or asynchronous. Use the appropriate execution method:

<CodeBlock
  code={hookSpecCode}
  lang="typescript"
  filename="__tests__/hooks/hook.spec.ts"
/>

### Hook Execution Methods

- `execute(instance, context)` - Execute synchronous hooks. Throws an error if any hook is asynchronous.
- `executeAsync(instance, context)` - Execute hooks asynchronously, supporting both sync and async hooks.

### Hook Context

Hooks receive a `HookContext` that provides access to:

- `instance` - The instance being hooked
- `scope` - The container scope
- `methodName` - The name of the method being executed
- `resolveArgs()` - Resolve method arguments from the container
- `invokeMethod(options)` - Invoke the hook method with arguments

## Best Practices

- **Use OnConstruct for initialization** - Initialize dependencies, validate state, or set up connections after construction
- **Use OnDispose for cleanup** - Close resources, save state, or unsubscribe from events before disposal
- **Keep hook logic simple** - Hooks should perform focused operations, not complex business logic
- **Resolve dependencies in hooks** - Use `ctx.resolveArgs()` to inject dependencies that weren't available at construction time
- **Handle async hooks properly** - Use `executeAsync` when hooks may be asynchronous
- **Register hooks once** - Set up onConstruct and onDispose hooks when creating your root container
- **Prefer constructor injection** - Use property injection with hooks only when constructor injection isn't possible