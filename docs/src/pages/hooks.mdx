---
layout: ../layouts/BaseLayout.astro
title: Hooks
description: Hooks - Lifecycle hooks for instance initialization and cleanup (onConstruct, onDispose)
---

import CodeBlock from "../components/CodeBlock.astro";
import injectPropSpecCode from "../../../__tests__/readme/injectProp.spec.ts?raw";
import onConstructSpecCode from "../../../__tests__/hooks/OnConstruct.spec.ts?raw";
import onDisposeSpecCode from "../../../__tests__/hooks/OnDispose.spec.ts?raw";
import hookSpecCode from "../../../__tests__/hooks/hook.spec.ts?raw";
import customHooksSpecCode from "../../../__tests__/readme/customHooks.spec.ts?raw";

# Hooks

<p>
  Hooks provide a way to execute code at specific lifecycle points of an instance. They enable
  initialization logic after construction, cleanup logic before disposal, property injection,
  and custom lifecycle management. The hook system is flexible and extensible, allowing you to
  create custom hooks for your specific needs.
</p>

<h2 id="what-are-hooks">What are Hooks?</h2>

<p>
  Hooks are methods decorated with special decorators that execute at specific points in an
  instance's lifecycle. They can:
</p>

<ul>
  <li>Run initialization code after instance construction</li>
  <li>Execute cleanup logic before instance disposal</li>
  <li>Inject dependencies into properties</li>
  <li>Perform custom lifecycle operations</li>
</ul>

<p>
  The hook system uses <code>HooksRunner</code> to execute hooks, which can be synchronous or
  asynchronous. Hooks can resolve dependencies from the container, making them powerful tools
  for managing complex initialization scenarios.
</p>

<h2 id="onconstruct">OnConstruct Hooks</h2>

<p>
  OnConstruct hooks execute after an instance is created. This is useful for initialization
  logic that needs access to the container or other dependencies that can't be injected via
  the constructor.
</p>

### Basic Usage

<p>
  Register an onConstruct hook on your container, then decorate methods with <code>@onConstruct</code>:
</p>

<CodeBlock
  code={onConstructSpecCode}
  lang="typescript"
  filename="__tests__/hooks/OnConstruct.spec.ts"
/>

### Use Cases
<ul>
  <li>Post-construction initialization that requires container access</li>
  <li>Setting up properties that depend on other container services</li>
  <li>Validation or setup logic that needs to run after all dependencies are injected</li>
  <li>Initializing relationships or connections</li>
</ul>

<h2 id="ondispose">OnDispose Hooks</h2>

<p>
  OnDispose hooks execute before an instance is disposed, allowing you to clean up resources,
  save state, or perform other cleanup operations.
</p>

### Basic Usage

<p>
  Register an onDispose hook on your container, then decorate methods with <code>@onDispose</code>:
</p>

<CodeBlock
  code={onDisposeSpecCode}
  lang="typescript"
  filename="__tests__/hooks/OnDispose.spec.ts"
/>

### Use Cases
<ul>
  <li>Closing database connections or file handles</li>
  <li>Saving state or flushing buffers</li>
  <li>Unsubscribing from events or observers</li>
  <li>Releasing external resources</li>
  <li>Logging cleanup operations</li>
</ul>

<h2 id="property-injection">Property Injection</h2>

<p>
  Property injection allows you to inject dependencies into properties using hooks. This is
  useful when constructor injection isn't possible or when you need to inject into base class
  properties.
</p>

### Using injectProp with Hooks

<p>
  The <code>injectProp</code> helper can be used with the <code>@hook</code> decorator to inject
  dependencies into properties:
</p>

<CodeBlock
  code={injectPropSpecCode}
  lang="typescript"
  filename="__tests__/readme/injectProp.spec.ts"
/>

### When to Use Property Injection
<ul>
  <li>Injecting into base class properties</li>
  <li>Optional dependencies that might not always be available</li>
  <li>Circular dependency scenarios</li>
  <li>Framework integration where constructor injection is limited</li>
</ul>

<h2 id="custom-hooks">Custom Hooks</h2>

<p>
  You can create custom hooks for any lifecycle event or application-specific scenario. Custom
  hooks use the same <code>HooksRunner</code> system but with your own hook names.
</p>

### Creating Custom Hooks

<p>
  Create a custom hook by instantiating a <code>HooksRunner</code> with a unique hook name:
</p>

<CodeBlock
  code={customHooksSpecCode}
  lang="typescript"
  filename="__tests__/readme/customHooks.spec.ts"
/>

### Synchronous vs Asynchronous Hooks

<p>
  Hooks can be synchronous or asynchronous. Use the appropriate execution method:
</p>

<CodeBlock
  code={hookSpecCode}
  lang="typescript"
  filename="__tests__/hooks/hook.spec.ts"
/>

### Hook Execution Methods
<ul>
  <li>
    <code>execute(instance, context)</code> - Execute synchronous hooks. Throws an error if
    any hook is asynchronous.
  </li>
  <li>
    <code>executeAsync(instance, context)</code> - Execute hooks asynchronously, supporting
    both sync and async hooks.
  </li>
</ul>

### Hook Context

<p>
  Hooks receive a <code>HookContext</code> that provides access to:
</p>

<ul>
  <li><code>instance</code> - The instance being hooked</li>
  <li><code>scope</code> - The container scope</li>
  <li><code>methodName</code> - The name of the method being executed</li>
  <li><code>resolveArgs()</code> - Resolve method arguments from the container</li>
  <li><code>invokeMethod(options)</code> - Invoke the hook method with arguments</li>
</ul>

<h2 id="best-practices">Best Practices</h2>

<ul>
  <li>
    <strong>Use OnConstruct for initialization</strong> - Initialize dependencies, validate
    state, or set up connections after construction
  </li>
  <li>
    <strong>Use OnDispose for cleanup</strong> - Close resources, save state, or unsubscribe
    from events before disposal
  </li>
  <li>
    <strong>Keep hook logic simple</strong> - Hooks should perform focused operations, not
    complex business logic
  </li>
  <li>
    <strong>Resolve dependencies in hooks</strong> - Use <code>ctx.resolveArgs()</code> to
    inject dependencies that weren't available at construction time
  </li>
  <li>
    <strong>Handle async hooks properly</strong> - Use <code>executeAsync</code> when hooks
    may be asynchronous
  </li>
  <li>
    <strong>Register hooks once</strong> - Set up onConstruct and onDispose hooks when creating
    your root container
  </li>
  <li>
    <strong>Prefer constructor injection</strong> - Use property injection with hooks only when
    constructor injection isn't possible
  </li>
</ul>