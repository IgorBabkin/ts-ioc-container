---
import BaseLayout from "../layouts/BaseLayout.astro";
import CodeBlock from "../components/CodeBlock.astro";
import dependencyResolutionFlowDiagram from "../diagrams/dependency-resolution-flow.mermaid?raw";
import scopeHierarchyDiagram from "../diagrams/scope-hierarchy.mermaid?raw";
---

<BaseLayout
  title="Container"
  description="Container - Core container functionality, scopes, and instance management"
>
  <article>
    <h1>Container</h1>

    <p>
      The <code>Container</code> is the central component of the IoC system. It manages
      the lifecycle of dependencies, resolves them when requested, and maintains scoped
      instances. Understanding containers is essential for effective dependency injection.
    </p>

    <h2>Scopes</h2>

    <p>
      Scopes allow you to create isolated dependency contexts. This is perfect
      for request-level isolation in web applications or feature-level
      separation. Each scope can have tags that control which providers are
      available.
    </p>

    <h3>Creating Scopes</h3>

    <CodeBlock
      code={`import { Container, type IContainer, inject, select } from 'ts-ioc-container';

class App {
  constructor(@inject(select.scope.current) public scope: IContainer) {}
}

const root = new Container({ tags: ['root'] });
const app = root.resolve(App);

expect(app.scope).toBe(root);`}
      lang="typescript"
    />

    <h3>Tagged Scopes</h3>

    <p>
      Tags allow you to control which providers are available in which scopes.
      This is useful for environment-specific configurations or feature flags.
    </p>

    <CodeBlock
      code={`import {
  Container,
  DependencyNotFoundError,
  register,
  Registration as R,
  scope,
  singleton,
  bindTo,
} from 'ts-ioc-container';

@register(
  bindTo('ILogger'),
  scope((s) => s.hasTag('child')),
  singleton()
)
class Logger {}

const root = new Container({ tags: ['root'] })
  .addRegistration(R.fromClass(Logger));
const child = root.createScope({ tags: ['child'] });

// Logger is available in child scope
expect(child.resolve('ILogger')).toBeInstanceOf(Logger);

// Logger is NOT available in root scope
expect(() => root.resolve('ILogger')).toThrow(DependencyNotFoundError);`}
      lang="typescript"
    />

    <h3>Scope Hierarchy</h3>

    <p>
      Containers can create child scopes, forming a tree structure. Each scope
      maintains its own provider registry and instance cache, but can fall back
      to parent scopes for resolution.
    </p>

    <div class="diagram">
      <div class="mermaid" set:html={scopeHierarchyDiagram} />
    </div>

    <h3>Scope Resolution Strategy</h3>

    <p>When resolving a dependency, the container follows this strategy:</p>

    <ol>
      <li>Check if provider exists in current scope</li>
      <li>
        Check if provider has access in current scope (visibility predicate)
      </li>
      <li>If not found, recursively check parent scopes</li>
      <li>If found in parent, check access from current scope</li>
      <li>Throw <code>DependencyNotFoundError</code> if not found anywhere</li>
    </ol>

    <h2>Dependency Resolution Flow</h2>

    <p>
      The following sequence diagram illustrates how a dependency is resolved
      from the container:
    </p>

    <div class="diagram">
      <div class="mermaid" set:html={dependencyResolutionFlowDiagram} />
    </div>

    <h2>Instance Management</h2>

    <p>
      The container tracks all instances it creates, allowing you to query and
      manage them. This is particularly useful for cleanup operations,
      debugging, or implementing custom lifecycle management.
    </p>

    <h3>Querying Instances</h3>

    <CodeBlock
      code={`import { Container, inject, Registration as R, select, bindTo, register } from 'ts-ioc-container';

@register(bindTo('ILogger'))
class Logger {}

class App {
  constructor(@inject(select.instances()) public loggers: Logger[]) {}
}

const root = new Container({ tags: ['root'] })
  .addRegistration(R.fromClass(Logger));
const child = root.createScope({ tags: ['child'] });

root.resolve('ILogger');
child.resolve('ILogger');

const rootApp = root.resolve(App);
const childApp = child.resolve(App);

// Child scope sees only its own instance
expect(childApp.loggers.length).toBe(1);

// Root scope sees all instances (cascading)
expect(rootApp.loggers.length).toBe(2);`}
      lang="typescript"
    />

    <h3>Filtering Instances</h3>

    <CodeBlock
      code={`const isLogger = (instance: unknown) => instance instanceof Logger;

class App {
  constructor(@inject(select.instances(isLogger)) public loggers: Logger[]) {}
}`}
      lang="typescript"
    />

    <h2>Disposal</h2>

    <p>
      Proper resource cleanup is essential for preventing memory leaks. The
      container provides a disposal mechanism that cleans up all resources and
      prevents further usage.
    </p>

    <CodeBlock
      code={`import { Container, ContainerDisposedError, Registration as R, select } from 'ts-ioc-container';

class Logger {}

const container = new Container({ tags: ['root'] })
  .addRegistration(R.fromClass(Logger).bindToKey('ILogger'));

container.dispose();

// All subsequent operations throw ContainerDisposedError
expect(() => container.resolve('ILogger')).toThrow(ContainerDisposedError);
expect(select.instances().resolve(container).length).toBe(0);`}
      lang="typescript"
    />

    <h3>Disposal Behavior</h3>
    <ul>
      <li>Disposes the container and all child scopes</li>
      <li>Unregisters all providers</li>
      <li>Clears all cached instances</li>
      <li>
        Throws <code>ContainerDisposedError</code> on any subsequent operations
      </li>
    </ul>

    <h2>Lazy Loading</h2>

    <p>
      Lazy loading defers the instantiation of dependencies until they're
      actually accessed. This can improve startup performance and enable
      circular dependency resolution.
    </p>

    <CodeBlock
      code={`import { Container, inject, register, Registration as R, select as s, singleton } from 'ts-ioc-container';

@register(singleton())
class Flag {
  isSet = false;
  set() {
    this.isSet = true;
  }
}

class Service {
  name = 'Service';
  constructor(@inject('Flag') private flag: Flag) {
    this.flag.set();
  }
  greet() {
    return 'Hello';
  }
}

class App {
  constructor(@inject(s.token('Service').lazy()) public service: Service) {}
  run() {
    return this.service.greet();
  }
}

const container = new Container()
  .addRegistration(R.fromClass(Flag))
  .addRegistration(R.fromClass(Service));

const app = container.resolve(App);
const flag = container.resolve<Flag>('Flag');

// Service is not created yet
expect(flag.isSet).toBe(false);

// Service is created when method is invoked
expect(app.run()).toBe('Hello');
expect(flag.isSet).toBe(true);`}
      lang="typescript"
    />

    <h2>Memory Management</h2>

    <p>The container provides explicit disposal to prevent memory leaks:</p>
    <ul>
      <li><code>dispose()</code> clears all providers and instances</li>
      <li>Child scopes are automatically disposed when parent is disposed</li>
      <li>Instance tracking allows manual cleanup if needed</li>
      <li>Hooks can be used to release external resources</li>
    </ul>

    <h2>Key Design Decisions</h2>

    <h3>1. Separation of Concerns</h3>
    <p>The architecture separates three distinct responsibilities:</p>
    <ul>
      <li>
        <strong>Container</strong>: Manages lifecycle and coordinates resolution
      </li>
      <li><strong>Provider</strong>: Handles instance creation</li>
      <li><strong>Injector</strong>: Handles dependency injection</li>
    </ul>
    <p>
      This separation makes each component testable and replaceable
      independently.
    </p>

    <h3>2. Scope-Based Isolation</h3>
    <p>
      Scopes provide isolation while maintaining a parent-child relationship.
      This design enables:
    </p>
    <ul>
      <li>Request-level isolation in web applications</li>
      <li>Feature-level separation</li>
      <li>Hierarchical dependency resolution</li>
      <li>Per-scope singleton instances</li>
    </ul>

    <h3>3. Tag-Based Scoping</h3>
    <p>
      Tags provide a flexible way to control provider availability without
      hardcoding scope relationships. This:
    </p>
    <ul>
      <li>Enables environment-specific configurations</li>
      <li>Supports feature flags</li>
      <li>Allows dynamic scope matching</li>
      <li>Makes testing easier</li>
    </ul>

    <h3>4. Composite Pattern</h3>
    <p>
      The scope hierarchy uses the Composite pattern, where containers can
      contain other containers. This allows uniform treatment of individual
      containers and container hierarchies.
    </p>

    <h3>5. Null Object Pattern</h3>
    <p>
      The <code>EmptyContainer</code> class implements the Null Object pattern, providing
      a safe default parent for root containers. This eliminates null checks throughout
      the codebase.
    </p>

    <h2>Best Practices</h2>

    <ul>
      <li>
        <strong>Always dispose containers</strong> when they're no longer needed,
        especially in long-running applications
      </li>
      <li>
        <strong>Use scopes for isolation</strong> - Create request-level scopes in
        web applications to prevent cross-request contamination
      </li>
      <li>
        <strong>Tag your scopes</strong> - Use meaningful tags to control provider
        availability and make your code more maintainable
      </li>
      <li>
        <strong>Query instances carefully</strong> - Be aware of cascading behavior
        when querying instances across scopes
      </li>
      <li>
        <strong>Use lazy loading wisely</strong> - Lazy loading can help with performance,
        but be aware of when dependencies are actually created
      </li>
    </ul>

    <h2>API Reference</h2>

    <h3>Container Methods</h3>
    <ul>
      <li>
        <code
          >resolve&lt;T&gt;(key: DependencyKey | constructor&lt;T&gt;, options?:
          ResolveOptions): T</code
        > - Resolve a dependency
      </li>
      <li>
        <code>createScope(options?: ScopeOptions): IContainer</code> - Create a child
        scope
      </li>
      <li>
        <code>addRegistration(registration: IRegistration): IContainer</code> - Register
        a provider
      </li>
      <li>
        <code>dispose(): void</code> - Dispose the container and all resources
      </li>
      <li>
        <code>getInstances(): Iterable&lt;Instance&gt;</code> - Get all instances
        created by this container
      </li>
      <li>
        <code>hasTag(tag: Tag): boolean</code> - Check if container has a specific
        tag
      </li>
    </ul>
  </article>
</BaseLayout>

<style>
  .diagram {
    margin: 2rem 0;
    padding: 1.5rem;
    background: #f6f8fa;
    border: 1px solid #e1e4e8;
    border-radius: 8px;
    overflow-x: auto;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
  }

  .diagram .mermaid {
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 200px;
  }

  .diagram pre {
    margin: 0;
    background: transparent;
    border: none;
    padding: 0;
  }

  .diagram code {
    background: transparent;
    padding: 0;
  }
</style>
