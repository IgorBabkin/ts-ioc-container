---
import BaseLayout from '../layouts/BaseLayout.astro';
---

<BaseLayout title="Container" description="Container - Core container functionality, scopes, and instance management">
  <article>
    <h1>Container</h1>
    
    <p>
      The <code>Container</code> is the central component of the IoC system. It manages the lifecycle of dependencies,
      resolves them when requested, and maintains scoped instances. Understanding containers is essential for effective
      dependency injection.
    </p>

    <h2>Core Concepts</h2>
    
    <p>The container is built on three fundamental concepts:</p>
    <ul>
      <li><strong>Provider</strong>: A factory that creates dependency instances</li>
      <li><strong>Injector</strong>: Describes how dependencies are injected into constructors</li>
      <li><strong>Registration</strong>: Connects providers to the container with keys and configuration</li>
    </ul>

    <h2>Basic Usage</h2>
    
    <p>Creating and using a container is straightforward:</p>
    
    <pre><code class="language-typescript">{`import { Container, inject, Registration as R } from 'ts-ioc-container';

// Define your service
class Logger {
  log(message: string) {
    console.log(message);
  }
}

// Define a class that depends on Logger
class App {
  constructor(@inject('ILogger') private logger: Logger) {}

  run() {
    this.logger.log('Hello, IoC!');
  }
}

// Create and configure container
const container = new Container()
  .addRegistration(R.fromClass(Logger).bindToKey('ILogger'));

// Resolve and use
const app = container.resolve(App);
app.run(); // Output: Hello, IoC!`}</code></pre>

    <h2>Scopes</h2>
    
    <p>
      Scopes allow you to create isolated dependency contexts. This is perfect for request-level isolation in web
      applications or feature-level separation. Each scope can have tags that control which providers are available.
    </p>

    <h3>Creating Scopes</h3>
    
    <pre><code class="language-typescript">{`import { Container, type IContainer, inject, select } from 'ts-ioc-container';

class App {
  constructor(@inject(select.scope.current) public scope: IContainer) {}
}

const root = new Container({ tags: ['root'] });
const app = root.resolve(App);

expect(app.scope).toBe(root);`}</code></pre>

    <h3>Tagged Scopes</h3>
    
    <p>
      Tags allow you to control which providers are available in which scopes. This is useful for environment-specific
      configurations or feature flags.
    </p>

    <pre><code class="language-typescript">{`import {
  Container,
  DependencyNotFoundError,
  register,
  Registration as R,
  scope,
  singleton,
  bindTo,
} from 'ts-ioc-container';

@register(
  bindTo('ILogger'),
  scope((s) => s.hasTag('child')),
  singleton()
)
class Logger {}

const root = new Container({ tags: ['root'] })
  .addRegistration(R.fromClass(Logger));
const child = root.createScope({ tags: ['child'] });

// Logger is available in child scope
expect(child.resolve('ILogger')).toBeInstanceOf(Logger);

// Logger is NOT available in root scope
expect(() => root.resolve('ILogger')).toThrow(DependencyNotFoundError);`}</code></pre>

    <h3>Scope Resolution</h3>
    
    <p>
      When a dependency isn't found in the current scope, the container automatically searches parent scopes. This
      allows you to have global dependencies accessible from any scope.
    </p>

    <h2>Instance Management</h2>
    
    <p>
      The container tracks all instances it creates, allowing you to query and manage them. This is particularly
      useful for cleanup operations, debugging, or implementing custom lifecycle management.
    </p>

    <h3>Querying Instances</h3>
    
    <pre><code class="language-typescript">{`import { Container, inject, Registration as R, select, bindTo, register } from 'ts-ioc-container';

@register(bindTo('ILogger'))
class Logger {}

class App {
  constructor(@inject(select.instances()) public loggers: Logger[]) {}
}

const root = new Container({ tags: ['root'] })
  .addRegistration(R.fromClass(Logger));
const child = root.createScope({ tags: ['child'] });

root.resolve('ILogger');
child.resolve('ILogger');

const rootApp = root.resolve(App);
const childApp = child.resolve(App);

// Child scope sees only its own instance
expect(childApp.loggers.length).toBe(1);

// Root scope sees all instances (cascading)
expect(rootApp.loggers.length).toBe(2);`}</code></pre>

    <h3>Filtering Instances</h3>
    
    <pre><code class="language-typescript">{`const isLogger = (instance: unknown) => instance instanceof Logger;

class App {
  constructor(@inject(select.instances(isLogger)) public loggers: Logger[]) {}
}`}</code></pre>

    <h2>Disposal</h2>
    
    <p>
      Proper resource cleanup is essential for preventing memory leaks. The container provides a disposal mechanism
      that cleans up all resources and prevents further usage.
    </p>

    <pre><code class="language-typescript">{`import { Container, ContainerDisposedError, Registration as R, select } from 'ts-ioc-container';

class Logger {}

const container = new Container({ tags: ['root'] })
  .addRegistration(R.fromClass(Logger).bindToKey('ILogger'));

container.dispose();

// All subsequent operations throw ContainerDisposedError
expect(() => container.resolve('ILogger')).toThrow(ContainerDisposedError);
expect(select.instances().resolve(container).length).toBe(0);`}</code></pre>

    <h3>Disposal Behavior</h3>
    <ul>
      <li>Disposes the container and all child scopes</li>
      <li>Unregisters all providers</li>
      <li>Clears all cached instances</li>
      <li>Throws <code>ContainerDisposedError</code> on any subsequent operations</li>
    </ul>

    <h2>Lazy Loading</h2>
    
    <p>
      Lazy loading defers the instantiation of dependencies until they're actually accessed. This can improve startup
      performance and enable circular dependency resolution.
    </p>

    <pre><code class="language-typescript">{`import { Container, inject, register, Registration as R, select as s, singleton } from 'ts-ioc-container';

@register(singleton())
class Flag {
  isSet = false;
  set() {
    this.isSet = true;
  }
}

class Service {
  name = 'Service';
  constructor(@inject('Flag') private flag: Flag) {
    this.flag.set();
  }
  greet() {
    return 'Hello';
  }
}

class App {
  constructor(@inject(s.token('Service').lazy()) public service: Service) {}
  run() {
    return this.service.greet();
  }
}

const container = new Container()
  .addRegistration(R.fromClass(Flag))
  .addRegistration(R.fromClass(Service));

const app = container.resolve(App);
const flag = container.resolve<Flag>('Flag');

// Service is not created yet
expect(flag.isSet).toBe(false);

// Service is created when method is invoked
expect(app.run()).toBe('Hello');
expect(flag.isSet).toBe(true);`}</code></pre>

    <h2>Best Practices</h2>
    
    <ul>
      <li>
        <strong>Always dispose containers</strong> when they're no longer needed, especially in long-running
        applications
      </li>
      <li>
        <strong>Use scopes for isolation</strong> - Create request-level scopes in web applications to prevent
        cross-request contamination
      </li>
      <li>
        <strong>Tag your scopes</strong> - Use meaningful tags to control provider availability and make your code
        more maintainable
      </li>
      <li>
        <strong>Query instances carefully</strong> - Be aware of cascading behavior when querying instances across
        scopes
      </li>
      <li>
        <strong>Use lazy loading wisely</strong> - Lazy loading can help with performance, but be aware of when
        dependencies are actually created
      </li>
    </ul>

    <h2>API Reference</h2>
    
    <h3>Container Methods</h3>
    <ul>
      <li><code>resolve&lt;T&gt;(key: DependencyKey | constructor&lt;T&gt;, options?: ResolveOptions): T</code> - Resolve a dependency</li>
      <li><code>createScope(options?: ScopeOptions): IContainer</code> - Create a child scope</li>
      <li><code>addRegistration(registration: IRegistration): IContainer</code> - Register a provider</li>
      <li><code>dispose(): void</code> - Dispose the container and all resources</li>
      <li><code>getInstances(): Iterable&lt;Instance&gt;</code> - Get all instances created by this container</li>
      <li><code>hasTag(tag: Tag): boolean</code> - Check if container has a specific tag</li>
    </ul>
  </article>
</BaseLayout>
